<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Particle Conquest Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: system-ui, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            padding-top: max(12px, env(safe-area-inset-top));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            pointer-events: none;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }
        
        .player-dot.player { background: #0ff; box-shadow: 0 0 10px #0ff; }
        .player-dot.enemy { background: #f44; box-shadow: 0 0 10px #f44; }
        
        .player-stats {
            font-size: 22px;
            font-weight: bold;
            color: #fff;
        }
        
        .game-status {
            font-size: 13px;
            color: #888;
            text-align: center;
        }
        
        /* Abilities Bar */
        .abilities-bar {
            position: fixed;
            bottom: calc(80px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            background: rgba(30,30,30,0.9);
            border: 2px solid #444;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .ability-btn:hover:not(.cooldown) {
            border-color: #0ff;
            transform: scale(1.1);
        }
        
        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .ability-btn .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            transition: height 0.1s linear;
        }
        
        .ability-btn .key-hint {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
        
        .ability-btn.active {
            border-color: #0ff;
            box-shadow: 0 0 20px #0ff;
        }
        
        /* Speed Controls */
        .speed-controls {
            position: fixed;
            top: 60px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .speed-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: #222;
            border: 1px solid #444;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .speed-btn.active {
            background: #0af;
            color: #000;
            border-color: #0af;
        }
        
        /* Send Percent */
        .send-percent {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .percent-btn {
            padding: 8px 16px;
            font-size: 13px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .percent-btn.active {
            background: #0af;
            color: #000;
            border-color: #0af;
        }
        
        /* Level Info */
        .level-info {
            position: fixed;
            top: 55px;
            left: 20px;
            color: #555;
            font-size: 12px;
            z-index: 100;
        }
        
        /* Planet Legend */
        .planet-legend {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: max(20px, env(safe-area-inset-left));
            font-size: 10px;
            color: #555;
            z-index: 100;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        
        .legend-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid;
        }
        
        /* Menu */
        .menu {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 20px;
        }
        
        .menu h1 {
            font-size: 42px;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu .subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 30px;
        }
        
        .menu-section {
            margin-bottom: 25px;
            text-align: center;
        }
        
        .menu-section h3 {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 12px;
        }
        
        .difficulty-btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .diff-btn {
            padding: 12px 20px;
            font-size: 14px;
            border: 2px solid #333;
            background: #111;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .diff-btn:hover { transform: scale(1.05); }
        .diff-btn.easy { border-color: #4a4; }
        .diff-btn.easy:hover { background: #4a42; }
        .diff-btn.medium { border-color: #aa4; }
        .diff-btn.medium:hover { background: #aa42; }
        .diff-btn.hard { border-color: #a44; }
        .diff-btn.hard:hover { background: #a442; }
        .diff-btn.insane { border-color: #a4a; }
        .diff-btn.insane:hover { background: #a4a2; }
        
        .mode-btn {
            padding: 12px 25px;
            font-size: 14px;
            border: 2px solid #555;
            background: #111;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 5px;
        }
        
        .mode-btn:hover { transform: scale(1.05); border-color: #888; }
        .mode-btn.active { border-color: #0ff; background: rgba(0, 255, 255, 0.1); }
        
        .harvest-hud {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 90;
        }
        
        .harvest-title {
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 20px #000;
            margin-bottom: 10px;
        }
        
        .harvest-subtitle {
            font-size: 16px;
            color: #aaa;
        }
        
        .harvest-progress {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 100;
        }
        
        .harvest-bar {
            width: 150px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #444;
        }
        
        .harvest-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }
        
        .harvest-bar-fill.player { background: linear-gradient(90deg, #0aa, #0ff); }
        .harvest-bar-fill.enemy { background: linear-gradient(90deg, #a44, #f66); }
        
        .harvest-count {
            font-size: 14px;
            color: #888;
        }
        
        .instructions {
            max-width: 380px;
            text-align: left;
            color: #666;
            font-size: 12px;
            line-height: 1.5;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(255,255,255,0.02);
        }
        
        .instructions h4 {
            color: #888;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: uppercase;
        }
        
        .instructions strong { color: #0ff; }
        .instructions em { color: #f84; font-style: normal; }

        .hidden { display: none !important; }

        /* Feature Toggles */
        .feature-toggles {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .feature-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: #111;
            border: 1px solid #333;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .feature-toggle:hover {
            border-color: #555;
        }

        .feature-toggle.active {
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.1);
        }

        .feature-toggle .toggle-icon {
            font-size: 16px;
        }

        .feature-toggle .toggle-label {
            color: #888;
            font-size: 12px;
        }

        .feature-toggle.active .toggle-label {
            color: #0ff;
        }

        .feature-toggle .toggle-check {
            width: 16px;
            height: 16px;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: transparent;
        }

        .feature-toggle.active .toggle-check {
            border-color: #0ff;
            background: #0ff;
            color: #000;
        }
        
        /* Result Screen */
        .result-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .result-screen h1 {
            font-size: 56px;
            margin-bottom: 15px;
        }
        
        .result-screen.victory h1 { color: #0ff; text-shadow: 0 0 50px #0ff; }
        .result-screen.defeat h1 { color: #f44; text-shadow: 0 0 50px #f44; }
        
        .result-screen p {
            color: #888;
            font-size: 18px;
            margin-bottom: 25px;
        }
        
        .play-again-btn {
            padding: 12px 35px;
            font-size: 16px;
            background: linear-gradient(135deg, #0ff, #0af);
            border: none;
            color: #000;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
        }
        
        /* Floating Combat Text */
        .float-text {
            position: fixed;
            pointer-events: none;
            font-weight: bold;
            font-size: 18px;
            animation: floatUp 1s ease-out forwards;
            z-index: 150;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }
        
        /* Ability tooltip */
        .ability-tooltip {
            position: fixed;
            background: rgba(0,0,0,0.9);
            border: 1px solid #444;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #fff;
            pointer-events: none;
            z-index: 300;
            max-width: 200px;
        }
        
        .ability-tooltip .title {
            color: #0ff;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        /* Pause Button */
        .pause-btn {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
            width: 44px;
            height: 44px;
            background: rgba(30, 30, 30, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .pause-btn:hover {
            border-color: #0ff;
            transform: scale(1.1);
        }

        /* Pause Menu */
        .pause-menu {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 250;
            padding: 20px;
        }

        .pause-menu h1 {
            font-size: 48px;
            color: #fff;
            margin-bottom: 10px;
        }

        .pause-menu .pause-subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 30px;
        }

        .pause-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 30px;
        }

        .pause-menu-btn {
            padding: 14px 50px;
            font-size: 16px;
            border: 2px solid #444;
            background: #111;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 220px;
            text-align: center;
        }

        .pause-menu-btn:hover {
            border-color: #0ff;
            transform: scale(1.03);
        }

        .pause-menu-btn.primary {
            background: linear-gradient(135deg, #0ff, #0af);
            border: none;
            color: #000;
            font-weight: bold;
        }

        .pause-menu-btn.danger {
            border-color: #a44;
        }

        .pause-menu-btn.danger:hover {
            border-color: #f44;
            background: rgba(255, 68, 68, 0.1);
        }

        /* Pause Settings Section */
        .pause-settings {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            max-width: 350px;
            width: 100%;
        }

        .pause-settings h3 {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 15px;
            text-align: center;
        }

        .pause-settings .feature-toggles {
            justify-content: center;
        }

        /* Stats Screen */
        .stats-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 20px;
            overflow-y: auto;
        }

        .stats-screen h1 {
            font-size: 36px;
            color: #0ff;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            max-width: 600px;
            width: 100%;
            margin-bottom: 25px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-card .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #0ff;
        }

        .stat-card .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .stats-close-btn {
            padding: 12px 40px;
            font-size: 16px;
            background: #222;
            border: 2px solid #444;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
        }

        .stats-close-btn:hover {
            border-color: #0ff;
        }

        /* Daily Challenges Panel */
        .daily-panel {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
            max-width: 350px;
            width: 100%;
        }

        .daily-panel h3 {
            color: #ffd700;
            font-size: 14px;
            margin-bottom: 12px;
            text-align: center;
        }

        .challenge-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .challenge-item.completed {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0a0;
        }

        .challenge-icon {
            font-size: 20px;
        }

        .challenge-info {
            flex: 1;
        }

        .challenge-title {
            font-size: 12px;
            color: #fff;
            font-weight: bold;
        }

        .challenge-desc {
            font-size: 10px;
            color: #888;
        }

        .challenge-check {
            font-size: 18px;
            color: #0f0;
        }

        /* Multiplayer Lobby */
        .multiplayer-lobby {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 20px;
        }

        .multiplayer-lobby h1 {
            font-size: 36px;
            color: #0ff;
            margin-bottom: 10px;
        }

        .lobby-status {
            color: #888;
            margin-bottom: 25px;
        }

        .room-code-display {
            font-size: 48px;
            font-family: monospace;
            color: #ffd700;
            letter-spacing: 8px;
            background: rgba(255, 215, 0, 0.1);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            margin-bottom: 20px;
        }

        .join-code-input {
            font-size: 24px;
            font-family: monospace;
            text-align: center;
            letter-spacing: 5px;
            background: #111;
            border: 2px solid #444;
            color: #fff;
            padding: 12px 20px;
            border-radius: 10px;
            width: 200px;
            text-transform: uppercase;
        }

        .join-code-input:focus {
            border-color: #0ff;
            outline: none;
        }

        .lobby-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .lobby-btn {
            padding: 12px 30px;
            font-size: 16px;
            border: 2px solid #444;
            background: #111;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
        }

        .lobby-btn:hover {
            border-color: #0ff;
        }

        .lobby-btn.primary {
            background: linear-gradient(135deg, #0ff, #0af);
            border: none;
            color: #000;
            font-weight: bold;
        }

        /* Menu buttons for new features */
        .menu-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .menu-action-btn {
            padding: 10px 20px;
            font-size: 13px;
            background: #111;
            border: 1px solid #444;
            color: #aaa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-action-btn:hover {
            border-color: #0ff;
            color: #fff;
        }

        /* Sound toggle */
        .sound-toggle {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            left: max(20px, env(safe-area-inset-left));
            width: 40px;
            height: 40px;
            background: rgba(30, 30, 30, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sound-toggle:hover {
            border-color: #0ff;
        }

        .sound-toggle.muted {
            color: #666;
        }

        /* Ad-free badge */
        .ad-free-badge {
            position: fixed;
            bottom: max(10px, env(safe-area-inset-bottom));
            right: max(10px, env(safe-area-inset-right));
            font-size: 9px;
            color: #444;
            z-index: 50;
        }

        /* Selection count indicator */
        .selection-indicator {
            position: fixed;
            bottom: calc(150px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            padding: 8px 20px;
            border-radius: 20px;
            color: #0ff;
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Pause Button -->
    <button class="pause-btn hidden" id="pauseBtn" title="Pause (P)">‚è∏Ô∏è</button>

    <!-- Pause Menu -->
    <div class="pause-menu hidden" id="pauseMenu">
        <h1>‚è∏Ô∏è PAUSED</h1>
        <p class="pause-subtitle">Game paused - take a breather!</p>

        <div class="pause-menu-buttons">
            <button class="pause-menu-btn primary" id="resumeBtn">‚ñ∂Ô∏è Resume</button>
            <button class="pause-menu-btn" id="restartBtn">üîÑ Restart Level</button>
            <button class="pause-menu-btn danger" id="quitBtn">üö™ Quit to Menu</button>
        </div>

        <div class="pause-settings">
            <h3>Settings</h3>
            <div class="feature-toggles" id="pauseFeatureToggles">
                <div class="feature-toggle" data-feature="stealth">
                    <span class="toggle-icon">üëª</span>
                    <span class="toggle-label">Stealth</span>
                    <span class="toggle-check">‚úì</span>
                </div>
                <div class="feature-toggle" data-feature="comets">
                    <span class="toggle-icon">‚òÑÔ∏è</span>
                    <span class="toggle-label">Comets</span>
                    <span class="toggle-check">‚úì</span>
                </div>
                <div class="feature-toggle" data-feature="fog">
                    <span class="toggle-icon">üå´Ô∏è</span>
                    <span class="toggle-label">Fog</span>
                    <span class="toggle-check">‚úì</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Sound Toggle -->
    <button class="sound-toggle" id="soundToggle" title="Toggle Sound">üîä</button>

    <!-- Stats Screen -->
    <div class="stats-screen hidden" id="statsScreen">
        <h1>üìä Your Stats</h1>
        <div class="stats-grid" id="statsGrid"></div>
        <button class="stats-close-btn" id="statsCloseBtn">Close</button>
    </div>

    <!-- Multiplayer Lobby -->
    <div class="multiplayer-lobby hidden" id="multiplayerLobby">
        <h1 id="lobbyTitle">üåê Multiplayer</h1>
        <p class="lobby-status" id="lobbyStatus">Choose an option</p>

        <div id="roomCodeContainer" class="hidden">
            <div class="room-code-display" id="roomCodeDisplay">------</div>
            <p style="color:#888; font-size:12px;">Share this code with your friend</p>
        </div>

        <div id="joinCodeContainer">
            <input type="text" class="join-code-input" id="joinCodeInput" placeholder="ENTER CODE" maxlength="6">
        </div>

        <div class="lobby-buttons">
            <button class="lobby-btn" id="lobbyBackBtn">‚Üê Back</button>
            <button class="lobby-btn primary" id="lobbyHostBtn">Host Game</button>
            <button class="lobby-btn primary" id="lobbyJoinBtn">Join Game</button>
        </div>
    </div>

    <!-- Ad-free Badge -->
    <div class="ad-free-badge">‚ú® Ad-free ‚Ä¢ No login required</div>

    <div class="hud">
        <div class="player-info">
            <div class="player-dot player"></div>
            <div class="player-stats" id="playerStats">0</div>
            <span style="color:#0ff; font-size:12px; margin-left:5px;">YOU</span>
        </div>
        <div class="game-status" id="gameStatus">Select a planet</div>
        <div class="player-info">
            <span style="color:#f44; font-size:12px; margin-right:5px;">AI</span>
            <div class="player-stats" id="enemyStats">0</div>
            <div class="player-dot enemy"></div>
        </div>
    </div>

    <div class="level-info" id="levelInfo">Level 1</div>

    <div class="harvest-hud hidden" id="harvestHud">
        <div class="harvest-title">üåæ HARVEST PHASE</div>
        <div class="harvest-subtitle">Tap particles ‚Üí Tap YOUR planet to collect!</div>
    </div>

    <div class="harvest-progress hidden" id="harvestProgress">
        <div style="text-align:center;">
            <div class="harvest-bar"><div class="harvest-bar-fill player" id="playerHarvestBar" style="width:0%"></div></div>
            <div class="harvest-count"><span id="playerHarvested">0</span> collected</div>
        </div>
        <div class="harvest-count" id="remainingParticles">100 remaining</div>
        <div style="text-align:center;">
            <div class="harvest-bar"><div class="harvest-bar-fill enemy" id="enemyHarvestBar" style="width:0%"></div></div>
            <div class="harvest-count"><span id="enemyHarvested">0</span> collected</div>
        </div>
    </div>

    <div class="speed-controls" id="speedControls">
        <button class="speed-btn" data-speed="0.5">¬Ωx</button>
        <button class="speed-btn active" data-speed="1">1x</button>
        <button class="speed-btn" data-speed="2">2x</button>
        <button class="speed-btn" data-speed="3">3x</button>
    </div>

    <div class="abilities-bar" id="abilitiesBar">
        <button class="ability-btn" data-ability="boost" title="Speed Boost">
            ‚ö°
            <span class="key-hint">1</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="shield" title="Shield">
            üõ°Ô∏è
            <span class="key-hint">2</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="emp" title="EMP">
            üí•
            <span class="key-hint">3</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="nuke" title="Nuke">
            ‚ò¢Ô∏è
            <span class="key-hint">4</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="stealth" title="Stealth Attack" id="stealthBtn" style="display:none;">
            üëª
            <span class="key-hint">5</span>
            <div class="cooldown-overlay"></div>
        </button>
    </div>

    <div class="send-percent" id="sendPercent">
        <button class="percent-btn" data-pct="25">25%</button>
        <button class="percent-btn" data-pct="50">50%</button>
        <button class="percent-btn active" data-pct="75">75%</button>
        <button class="percent-btn" data-pct="100">ALL</button>
    </div>

    <div class="planet-legend" id="planetLegend">
        <div style="margin-bottom:8px; padding-bottom:5px; border-bottom:1px solid #333;">
            <div class="legend-item"><div class="legend-icon" style="background:#0ff;border-color:#0ff"></div> <span style="color:#0ff">Your planets (cyan ring)</span></div>
            <div class="legend-item"><div class="legend-icon" style="background:#f44;border-color:#f44"></div> <span style="color:#f44">Enemy planets (red ring)</span></div>
            <div class="legend-item"><div class="legend-icon" style="background:#666;border-color:#666"></div> Neutral (gray)</div>
        </div>
        <div class="legend-item"><div class="legend-icon" style="background:#4a4;border-color:#4a4"></div> Factory (2x prod)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#66f;border-color:#66f"></div> Fortress (2x defense)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#a4a;border-color:#a4a"></div> Wormhole (teleport OUT)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#222;border-color:#f44"></div> Black Hole (danger)</div>
        <div style="margin-top:8px; padding-top:5px; border-top:1px solid #333; color:#0ff;">
            <strong>Double-tap</strong> your planet = select ALL
        </div>
    </div>

    <div class="selection-indicator hidden" id="selectionIndicator">0 planets selected</div>

    <div class="menu" id="menu">
        <h1>üåç PARTICLE CONQUEST</h1>
        <p class="subtitle">Capture all planets to win</p>
        
        <div class="menu-section">
            <h3>Game Mode</h3>
            <div class="difficulty-btns">
                <button class="mode-btn active" data-mode="classic">‚öîÔ∏è Classic</button>
                <button class="mode-btn" data-mode="harvest">üåæ Harvest</button>
            </div>
        </div>
        
        <div class="menu-section">
            <h3>Select Difficulty</h3>
            <div class="difficulty-btns">
                <button class="diff-btn easy" data-diff="easy">Easy</button>
                <button class="diff-btn medium" data-diff="medium">Medium</button>
                <button class="diff-btn hard" data-diff="hard">Hard</button>
                <button class="diff-btn insane" data-diff="insane">Insane</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>Special Features</h3>
            <div class="feature-toggles">
                <div class="feature-toggle" data-feature="stealth">
                    <span class="toggle-icon">üëª</span>
                    <span class="toggle-label">Stealth Attack</span>
                    <span class="toggle-check">‚úì</span>
                </div>
                <div class="feature-toggle" data-feature="comets">
                    <span class="toggle-icon">‚òÑÔ∏è</span>
                    <span class="toggle-label">Comet Showers</span>
                    <span class="toggle-check">‚úì</span>
                </div>
                <div class="feature-toggle" data-feature="fog">
                    <span class="toggle-icon">üå´Ô∏è</span>
                    <span class="toggle-label">Fog of War</span>
                    <span class="toggle-check">‚úì</span>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h4>How to Play</h4>
            <div id="classicInstructions">
                <strong>Tap your planet</strong> ‚Üí <strong>Tap target</strong> to attack<br>
                <strong>Double-tap</strong> your planet ‚Üí Select ALL your planets<br>
                <strong>Tap multiple</strong> planets ‚Üí Unified attack<br><br>
            </div>
            <div id="harvestInstructions" style="display:none;">
                <strong>HARVEST PHASE:</strong> Tap particles ‚Üí Tap YOUR planet to collect<br>
                Race the AI to gather particles before battle begins!<br><br>
            </div>
            
            <h4>Special Planets</h4>
            <em>Factory</em> ‚Äî Produces 2x faster<br>
            <em>Fortress</em> ‚Äî Takes 50% less damage<br>
            <em>Wormhole</em> ‚Äî Units sent FROM here appear at partner<br>
            <em>Black Hole</em> ‚Äî Destroys nearby particles<br><br>
            
            <h4>Abilities (1-5 keys)</h4>
            ‚ö° <strong>Boost</strong> ‚Äî 3x particle speed for 5s<br>
            üõ°Ô∏è <strong>Shield</strong> ‚Äî Protect planet for 8s<br>
            üí• <strong>EMP</strong> ‚Äî Freeze enemy production 6s<br>
            ‚ò¢Ô∏è <strong>Nuke</strong> ‚Äî Destroy 50% units on target<br>
            üëª <strong>Stealth</strong> ‚Äî Hide particles for 3s (toggle on)<br><br>

            <h4>Special Features (toggle above)</h4>
            üëª <strong>Stealth Attack</strong> ‚Äî Your particles invisible to AI<br>
            ‚òÑÔ∏è <strong>Comet Showers</strong> ‚Äî Destroys flying particles<br>
            üå´Ô∏è <strong>Fog of War</strong> ‚Äî Limited visibility
        </div>

        <!-- Daily Challenges -->
        <div class="daily-panel" id="dailyPanel">
            <h3>üéØ Daily Challenges</h3>
            <div id="challengesList"></div>
        </div>

        <!-- Menu Actions -->
        <div class="menu-actions">
            <button class="menu-action-btn" id="statsBtn">üìä Stats</button>
            <button class="menu-action-btn" id="multiplayerBtn">üåê Multiplayer</button>
        </div>
    </div>

    <div class="result-screen hidden" id="resultScreen">
        <h1 id="resultTitle">VICTORY!</h1>
        <p id="resultText">You conquered the galaxy!</p>
        <button class="play-again-btn" id="playAgainBtn">Play Again</button>
    </div>

    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;

// ==================== LOCALSTORAGE & STATS SYSTEM ====================
const STORAGE_KEY = 'particleConquestPro';

const defaultStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    gamesLost: 0,
    planetsConquered: 0,
    planetsLost: 0,
    unitsDeployed: 0,
    unitsDestroyed: 0,
    highestLevel: 1,
    totalPlayTime: 0, // in seconds
    abilitiesUsed: 0,
    perfectWins: 0, // wins without losing a planet
    fastestWin: null, // in seconds
    currentStreak: 0,
    bestStreak: 0,
    dailyChallenges: {},
    lastDailyDate: null,
    settings: {
        soundEnabled: true,
        musicEnabled: true,
        volume: 0.7
    },
    features: {
        stealth: false,
        comets: false,
        fog: false
    }
};

let playerStats = loadStats();

function loadStats() {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            const parsed = JSON.parse(saved);
            return { ...defaultStats, ...parsed, settings: { ...defaultStats.settings, ...parsed.settings }, features: { ...defaultStats.features, ...parsed.features } };
        }
    } catch (e) { console.warn('Failed to load stats:', e); }
    return { ...defaultStats };
}

function saveStats() {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(playerStats));
    } catch (e) { console.warn('Failed to save stats:', e); }
}

// ==================== SOUND EFFECTS SYSTEM ====================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new AudioCtx();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

function playSound(type, options = {}) {
    if (!playerStats.settings.soundEnabled || !audioCtx) return;

    const vol = playerStats.settings.volume * (options.volume || 1);
    const now = audioCtx.currentTime;

    try {
        switch(type) {
            case 'select': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(vol * 0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            }
            case 'attack': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(vol * 0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
                break;
            }
            case 'capture': {
                [0, 0.1, 0.2].forEach((delay, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.setValueAtTime([523, 659, 784][i], now + delay);
                    gain.gain.setValueAtTime(vol * 0.25, now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.3);
                });
                break;
            }
            case 'lose': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.4);
                gain.gain.setValueAtTime(vol * 0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                break;
            }
            case 'victory': {
                [0, 0.15, 0.3, 0.45].forEach((delay, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.setValueAtTime([523, 659, 784, 1047][i], now + delay);
                    gain.gain.setValueAtTime(vol * 0.3, now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.4);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.4);
                });
                break;
            }
            case 'defeat': {
                [0, 0.2, 0.4].forEach((delay, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sawtooth';
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.setValueAtTime([300, 200, 100][i], now + delay);
                    gain.gain.setValueAtTime(vol * 0.25, now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.3);
                });
                break;
            }
            case 'ability': {
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(600, now);
                osc2.frequency.setValueAtTime(900, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
                osc2.frequency.exponentialRampToValueAtTime(1800, now + 0.15);
                gain.gain.setValueAtTime(vol * 0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc2.start(now);
                osc.stop(now + 0.2);
                osc2.stop(now + 0.2);
                break;
            }
            case 'comet': {
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, now);
                filter.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                const gain = audioCtx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(vol * 0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                noise.start(now);
                noise.stop(now + 0.5);
                break;
            }
            case 'click': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(1000, now);
                gain.gain.setValueAtTime(vol * 0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
                break;
            }
        }
    } catch (e) { console.warn('Sound error:', e); }
}

// ==================== DAILY CHALLENGES SYSTEM ====================
function getTodayKey() {
    return new Date().toISOString().split('T')[0];
}

function getDailySeed() {
    const today = getTodayKey();
    let hash = 0;
    for (let i = 0; i < today.length; i++) {
        hash = ((hash << 5) - hash) + today.charCodeAt(i);
        hash |= 0;
    }
    return Math.abs(hash);
}

function generateDailyChallenges() {
    const seed = getDailySeed();
    const challenges = [
        { id: 'speed_demon', title: '‚ö° Speed Demon', desc: 'Win a game in under 2 minutes', check: (g) => g.gameTime < 120 && g.won, reward: 'Fast fingers!' },
        { id: 'domination', title: 'üëë Domination', desc: 'Control all planets at once', check: (g) => g.allPlanetsOwned, reward: 'Total control!' },
        { id: 'underdog', title: 'üêï Underdog', desc: 'Win on Hard difficulty', check: (g) => g.difficulty === 'hard' && g.won, reward: 'Against the odds!' },
        { id: 'pacifist_start', title: 'üïäÔ∏è Patient General', desc: 'Win without attacking for first 30 seconds', check: (g) => g.noEarlyAttack && g.won, reward: 'Patience pays!' },
        { id: 'ability_master', title: 'üéØ Ability Master', desc: 'Use 3 different abilities in one game', check: (g) => g.abilitiesUsedTypes >= 3, reward: 'Tactical genius!' },
        { id: 'perfect_win', title: 'üíé Perfect Victory', desc: 'Win without losing any planet', check: (g) => g.perfectWin && g.won, reward: 'Flawless!' },
        { id: 'harvest_king', title: 'üåæ Harvest King', desc: 'Collect 60+ particles in Harvest mode', check: (g) => g.mode === 'harvest' && g.harvested >= 60, reward: 'Master collector!' },
        { id: 'fog_master', title: 'üå´Ô∏è Fog Master', desc: 'Win with Fog of War enabled', check: (g) => g.fogEnabled && g.won, reward: 'Blind victory!' },
        { id: 'nuke_happy', title: '‚ò¢Ô∏è Nuclear Option', desc: 'Use Nuke ability 3 times in one game', check: (g) => g.nukesUsed >= 3, reward: 'Boom!' },
        { id: 'streak', title: 'üî• On Fire', desc: 'Win 3 games in a row', check: (g) => playerStats.currentStreak >= 3, reward: 'Unstoppable!' }
    ];

    // Use seed to pick 3 challenges
    const shuffled = challenges.sort((a, b) => {
        const hashA = (seed * a.id.charCodeAt(0)) % 1000;
        const hashB = (seed * b.id.charCodeAt(0)) % 1000;
        return hashA - hashB;
    });

    return shuffled.slice(0, 3);
}

let dailyChallenges = [];
let currentGameStats = {};

function initDailyChallenges() {
    const today = getTodayKey();
    if (playerStats.lastDailyDate !== today) {
        playerStats.lastDailyDate = today;
        playerStats.dailyChallenges[today] = { completed: [] };
        saveStats();
    }
    dailyChallenges = generateDailyChallenges();
}

function resetCurrentGameStats() {
    currentGameStats = {
        startTime: Date.now(),
        gameTime: 0,
        won: false,
        difficulty: game.difficulty,
        mode: game.mode,
        allPlanetsOwned: false,
        noEarlyAttack: true,
        firstAttackTime: null,
        abilitiesUsedTypes: new Set(),
        perfectWin: true,
        planetsLostThisGame: 0,
        harvested: 0,
        fogEnabled: game.features.fog,
        nukesUsed: 0
    };
}

function checkDailyChallenges() {
    const today = getTodayKey();
    if (!playerStats.dailyChallenges[today]) {
        playerStats.dailyChallenges[today] = { completed: [] };
    }

    const completed = playerStats.dailyChallenges[today].completed;
    let newlyCompleted = [];

    dailyChallenges.forEach(challenge => {
        if (!completed.includes(challenge.id) && challenge.check(currentGameStats)) {
            completed.push(challenge.id);
            newlyCompleted.push(challenge);
        }
    });

    if (newlyCompleted.length > 0) {
        saveStats();
        newlyCompleted.forEach(c => {
            showFloatText(W / 2, H / 3, `üèÜ ${c.title}`, '#ffd700');
        });
    }
}

// ==================== MULTIPLAYER SYSTEM (PeerJS) ====================
let peer = null;
let conn = null;
let isHost = false;
let multiplayerActive = false;
let opponentName = 'Opponent';
let roomCode = '';

function generateRoomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
    return code;
}

async function initPeerJS() {
    return new Promise((resolve, reject) => {
        // Load PeerJS from CDN if not loaded
        if (typeof Peer === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load PeerJS'));
            document.head.appendChild(script);
        } else {
            resolve();
        }
    });
}

async function hostGame() {
    try {
        await initPeerJS();
        roomCode = generateRoomCode();
        peer = new Peer('pcp-' + roomCode);

        peer.on('open', id => {
            isHost = true;
            showMultiplayerLobby(true);
        });

        peer.on('connection', connection => {
            conn = connection;
            setupConnection();
        });

        peer.on('error', err => {
            console.error('Peer error:', err);
            showFloatText(W / 2, H / 2, 'Connection error!', '#f44');
        });
    } catch (e) {
        console.error('Failed to init multiplayer:', e);
    }
}

async function joinGame(code) {
    try {
        await initPeerJS();
        roomCode = code.toUpperCase();
        peer = new Peer();

        peer.on('open', () => {
            conn = peer.connect('pcp-' + roomCode);
            conn.on('open', () => {
                isHost = false;
                setupConnection();
            });
        });

        peer.on('error', err => {
            console.error('Peer error:', err);
            showFloatText(W / 2, H / 2, 'Room not found!', '#f44');
        });
    } catch (e) {
        console.error('Failed to join:', e);
    }
}

function setupConnection() {
    multiplayerActive = true;

    conn.on('data', data => {
        handleMultiplayerData(data);
    });

    conn.on('close', () => {
        multiplayerActive = false;
        showFloatText(W / 2, H / 2, 'Opponent disconnected', '#f44');
        endMultiplayerGame();
    });

    if (isHost) {
        // Host starts the game
        showFloatText(W / 2, H / 2, 'Opponent joined!', '#0f0');
        setTimeout(() => startMultiplayerGame(), 1000);
    } else {
        showFloatText(W / 2, H / 2, 'Connected!', '#0f0');
    }
}

function sendMultiplayerData(data) {
    if (conn && conn.open) {
        conn.send(data);
    }
}

function handleMultiplayerData(data) {
    switch(data.type) {
        case 'gameState':
            // Sync game state from host
            if (!isHost) {
                syncGameState(data.state);
            }
            break;
        case 'attack':
            // Opponent sent an attack
            executeOpponentAttack(data);
            break;
        case 'ability':
            // Opponent used an ability
            executeOpponentAbility(data);
            break;
        case 'sync':
            // Periodic sync
            if (!isHost) {
                syncPlanets(data.planets);
            }
            break;
    }
}

function syncGameState(state) {
    // Sync initial game state
    planets.forEach((p, i) => {
        if (state.planets[i]) {
            p.units = state.planets[i].units;
            p.owner = state.planets[i].owner;
        }
    });
}

function syncPlanets(planetData) {
    planetData.forEach((pd, i) => {
        if (planets[i]) {
            planets[i].units = pd.units;
            planets[i].owner = pd.owner;
        }
    });
}

function executeOpponentAttack(data) {
    const source = planets[data.sourceIdx];
    const target = planets[data.targetIdx];
    if (source && target) {
        const units = Math.floor(source.units * (data.percent / 100));
        source.units -= units;
        for (let i = 0; i < units; i++) {
            setTimeout(() => {
                const angle = Math.random() * Math.PI * 2;
                const dist = source.size + 5;
                flyingParticles.push(new FlyingParticle(
                    source.x + Math.cos(angle) * dist,
                    source.y + Math.sin(angle) * dist,
                    target,
                    ENEMY
                ));
            }, i * 30);
        }
    }
}

function executeOpponentAbility(data) {
    // Handle opponent ability usage
    showFloatText(W / 2, 100, `Opponent used ${data.ability}!`, '#f44');
}

function startMultiplayerGame() {
    game.state = 'playing';
    document.getElementById('multiplayerLobby').classList.add('hidden');
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');

    // Generate level with fixed seed for both players
    const mpSeed = roomCode.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
    generateMultiplayerLevel(mpSeed);

    if (isHost) {
        // Send initial state to opponent
        setTimeout(() => {
            sendMultiplayerData({
                type: 'gameState',
                state: {
                    planets: planets.map(p => ({ units: p.units, owner: p.owner, x: p.x, y: p.y }))
                }
            });
        }, 500);
    }
}

function generateMultiplayerLevel(seed) {
    // Simple seeded random
    let s = seed;
    const random = () => { s = (s * 9301 + 49297) % 233280; return s / 233280; };

    planets = [];
    flyingParticles = [];
    effects = [];
    comets = [];

    const numPlanets = 8;
    const positions = [];
    const minDist = 130;
    const margin = 80;

    for (let i = 0; i < numPlanets; i++) {
        let x, y, valid;
        let attempts = 0;
        do {
            valid = true;
            x = margin + random() * (W - margin * 2);
            y = margin + random() * (H - margin * 2);
            for (const pos of positions) {
                const dx = x - pos.x, dy = y - pos.y;
                if (Math.sqrt(dx*dx + dy*dy) < minDist) { valid = false; break; }
            }
            attempts++;
        } while (!valid && attempts < 100);

        positions.push({ x, y });
        const size = 25 + random() * 15;
        const planet = new Planet(x, y, size, 'normal');

        if (i === 0) {
            planet.owner = PLAYER;
            planet.units = 30;
        } else if (i === numPlanets - 1) {
            planet.owner = ENEMY;
            planet.units = 30;
        } else {
            planet.owner = NEUTRAL;
            planet.units = 10 + Math.floor(random() * 20);
        }
        planets.push(planet);
    }

    game.state = 'playing';
    document.getElementById('levelInfo').textContent = 'MULTIPLAYER';
}

function endMultiplayerGame() {
    multiplayerActive = false;
    if (peer) peer.destroy();
    peer = null;
    conn = null;
    document.getElementById('multiplayerLobby').classList.add('hidden');
}

function showMultiplayerLobby(hosting) {
    const lobby = document.getElementById('multiplayerLobby');
    lobby.classList.remove('hidden');
    document.getElementById('menu').classList.add('hidden');

    if (hosting) {
        document.getElementById('lobbyTitle').textContent = 'Hosting Game';
        document.getElementById('roomCodeDisplay').textContent = roomCode;
        document.getElementById('roomCodeDisplay').parentElement.classList.remove('hidden');
        document.getElementById('joinCodeInput').parentElement.classList.add('hidden');
        document.getElementById('lobbyStatus').textContent = 'Waiting for opponent...';
    }
}

// Game state
const game = {
    state: 'menu', // menu, harvest, playing, paused, ended
    mode: 'classic', // classic, harvest
    difficulty: 'medium',
    level: 1,
    selectedPlanets: [], // Changed to array for multi-select
    sendPercent: 75,
    speed: 1,
    activeAbility: null,
    lastClickTime: 0,
    lastClickedPlanet: null,
    doubleClickThreshold: 300, // ms
    paused: false,
    // Feature toggles
    features: {
        stealth: false,
        comets: false,
        fog: false
    }
};

// Comet system
let comets = [];
let lastCometShower = 0;
const COMET_SHOWER_INTERVAL = 15000; // 15 seconds between showers

// Harvest mode particles
let harvestParticles = [];
const HARVEST_PARTICLE_COUNT = 100;

// Abilities
const abilities = {
    boost: { cooldown: 0, maxCooldown: 20, duration: 5, active: false, activeTime: 0 },
    shield: { cooldown: 0, maxCooldown: 25, duration: 8, active: false, targetPlanet: null, activeTime: 0 },
    emp: { cooldown: 0, maxCooldown: 30, duration: 6, active: false, activeTime: 0 },
    nuke: { cooldown: 0, maxCooldown: 35, active: false, activeTime: 0 },
    stealth: { cooldown: 0, maxCooldown: 25, duration: 3, active: false, activeTime: 0 }
};

// Difficulty settings
const DIFFICULTY = {
    easy: { aiSpeed: 0.4, aiAggression: 0.25, planets: 6, startingUnits: 35, specialPlanets: 1 },
    medium: { aiSpeed: 0.7, aiAggression: 0.45, planets: 8, startingUnits: 40, specialPlanets: 2 },
    hard: { aiSpeed: 1.0, aiAggression: 0.65, planets: 10, startingUnits: 50, specialPlanets: 3 },
    insane: { aiSpeed: 1.3, aiAggression: 0.85, planets: 12, startingUnits: 60, specialPlanets: 4 }
};

// Planet types
const PLANET_TYPES = {
    normal: { productionMult: 1, defenseMult: 1, color: null },
    factory: { productionMult: 2, defenseMult: 1, color: '#44aa44', icon: '‚öôÔ∏è' },
    fortress: { productionMult: 0.7, defenseMult: 2, color: '#6666ff', icon: 'üè∞' },
    wormhole: { productionMult: 0.5, defenseMult: 1, color: '#aa44aa', icon: 'üåÄ' },
    blackhole: { productionMult: 0, defenseMult: 0, color: '#111111', icon: '‚ö´' }
};

// Owner constants
const NEUTRAL = 0, PLAYER = 1, ENEMY = 2;

// Helper to convert hex to rgba
function hexToRgba(hex, alpha) {
    hex = hex.replace('#', '');
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// Colors
const COLORS = {
    [NEUTRAL]: { main: '#666666', glow: '#444444', particle: '#888888' },
    [PLAYER]: { main: '#00ffff', glow: '#00aaff', particle: '#00ffff' },
    [ENEMY]: { main: '#ff4444', glow: '#ff2222', particle: '#ff6666' }
};

let planets = [];
let flyingParticles = [];
let bgParticles = [];
let effects = [];
let wormholePairs = [];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

// Effects system
class Effect {
    constructor(type, x, y, data = {}) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.data = data;
        this.age = 0;
        this.maxAge = data.duration || 1;
    }
    
    update(dt) {
        this.age += dt;
        return this.age < this.maxAge;
    }
    
    draw() {
        const progress = this.age / this.maxAge;
        
        switch(this.type) {
            case 'capture':
                const radius = this.data.radius * (1 + progress * 2);
                const alpha = 1 - progress;
                ctx.strokeStyle = hexToRgba(this.data.color, alpha);
                ctx.lineWidth = 4 * (1 - progress);
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 2;
                    const dist = radius * 0.8;
                    const px = this.x + Math.cos(angle) * dist;
                    const py = this.y + Math.sin(angle) * dist;
                    ctx.fillStyle = hexToRgba(this.data.color, alpha * 0.78);
                    ctx.beginPath();
                    ctx.arc(px, py, 4 * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 'explosion':
                const expRadius = 50 * progress;
                const expAlpha = 1 - progress;
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, expRadius);
                grad.addColorStop(0, `rgba(255, 200, 100, ${expAlpha})`);
                grad.addColorStop(0.5, `rgba(255, 100, 50, ${expAlpha * 0.5})`);
                grad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, expRadius, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'shield':
                if (!this.data.planet) return;
                const shieldAlpha = 0.3 + Math.sin(this.age * 10) * 0.1;
                ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.data.planet.x, this.data.planet.y, this.data.planet.size + 20, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha * 0.5})`;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + this.age;
                    const r = this.data.planet.size + 20;
                    ctx.beginPath();
                    ctx.moveTo(
                        this.data.planet.x + Math.cos(angle) * r,
                        this.data.planet.y + Math.sin(angle) * r
                    );
                    ctx.lineTo(
                        this.data.planet.x + Math.cos(angle + Math.PI/3) * r,
                        this.data.planet.y + Math.sin(angle + Math.PI/3) * r
                    );
                    ctx.stroke();
                }
                break;
                
            case 'wormhole':
                const wAlpha = 0.5 - progress * 0.5;
                ctx.strokeStyle = `rgba(170, 68, 170, ${wAlpha})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 20 + i * 10 + progress * 30, 
                           this.age * 3 + i, this.age * 3 + i + Math.PI);
                    ctx.stroke();
                }
                break;
                
            case 'selectAll':
                // Flash effect when selecting all planets
                const selectAlpha = (1 - progress) * 0.5;
                ctx.strokeStyle = `rgba(0, 255, 255, ${selectAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.data.radius + progress * 50, 0, Math.PI * 2);
                ctx.stroke();
                break;
        }
    }
}

// Planet class
class Planet {
    constructor(x, y, size, owner, units, type = 'normal') {
        this.x = x;
        this.y = y;
        this.size = size;
        this.owner = owner;
        this.units = units;
        this.type = type;
        this.typeData = PLANET_TYPES[type];
        this.maxUnits = Math.floor(size * 3);
        // ENHANCED: Production rate now scales more dramatically with size
        // Larger planets (size ~65) produce ~3x faster than small planets (size ~30)
        this.baseProductionRate = (size * size) / 2000; // Quadratic scaling
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.shielded = false;
        this.shieldTime = 0;
        this.empTime = 0;
        this.wormholePartner = null;
        this.incomingAttacks = [];
        this.orbitParticles = [];
        this.blackHoleAngle = 0;
        this.selected = false; // Track selection state
        
        const numOrbits = Math.floor(size / 15);
        for (let i = 0; i < numOrbits; i++) {
            this.orbitParticles.push({
                angle: Math.random() * Math.PI * 2,
                distance: size + 10 + Math.random() * 20,
                speed: (0.5 + Math.random() * 0.5) * (Math.random() < 0.5 ? 1 : -1)
            });
        }
    }
    
    get productionRate() {
        if (this.empTime > 0 && this.owner === ENEMY) return 0;
        return this.baseProductionRate * this.typeData.productionMult;
    }
    
    get defenseMult() {
        let mult = this.typeData.defenseMult;
        if (mult === 0) mult = 0.01;
        if (this.shielded) mult *= 10;
        return mult;
    }
    
    update(dt) {
        if (this.shieldTime > 0) {
            this.shieldTime -= dt;
            if (this.shieldTime <= 0) this.shielded = false;
        }
        
        if (this.empTime > 0) {
            this.empTime -= dt;
        }
        
        if (this.owner !== NEUTRAL && this.units < this.maxUnits && this.type !== 'blackhole') {
            this.units += this.productionRate * dt;
        }
        
        if (this.type === 'blackhole') {
            this.blackHoleAngle += dt * 2;
        }
        
        this.pulsePhase += dt * 2;
        
        for (const p of this.orbitParticles) {
            p.angle += p.speed * dt;
        }
        
        // Filter out stealthed player particles from incoming attacks (AI can't see them)
        this.incomingAttacks = flyingParticles.filter(p =>
            p.target === this && p.owner !== this.owner &&
            !(p.owner === PLAYER && p.stealthTime > 0)
        );
        
        // Update selection state based on game.selectedPlanets
        this.selected = game.selectedPlanets.includes(this);
    }
    
    draw() {
        const baseColor = this.typeData.color || COLORS[this.owner].main;
        const glowColor = this.typeData.color || COLORS[this.owner].glow;
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.05;
        
        // Black hole special rendering
        if (this.type === 'blackhole') {
            const bhGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
            bhGrad.addColorStop(0, '#000');
            bhGrad.addColorStop(0.5, 'rgba(50, 0, 50, 0.8)');
            bhGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = bhGrad;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 68, 68, 0.53)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size * 1.5, this.size * 0.5, 
                           this.blackHoleAngle + i * 0.5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#f44';
            ctx.lineWidth = 2;
            ctx.stroke();
            return;
        }
        
        // Wormhole special rendering
        if (this.type === 'wormhole') {
            ctx.strokeStyle = 'rgba(170, 68, 170, 0.53)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const spiralAngle = this.pulsePhase + i * Math.PI / 2;
                ctx.beginPath();
                for (let t = 0; t < 1; t += 0.05) {
                    const r = this.size * t;
                    const a = spiralAngle + t * Math.PI * 2;
                    const px = this.x + Math.cos(a) * r;
                    const py = this.y + Math.sin(a) * r;
                    if (t === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
        }
        
        // Glow
        const gradient = ctx.createRadialGradient(
            this.x, this.y, this.size * 0.5,
            this.x, this.y, this.size * 2
        );
        gradient.addColorStop(0, hexToRgba(glowColor, 0.25));
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Planet body
        ctx.fillStyle = hexToRgba(baseColor, 0.19);
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = this.type === 'fortress' ? 4 : 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // OWNERSHIP RING
        if (this.owner !== NEUTRAL) {
            const ownerColor = COLORS[this.owner].main;
            ctx.strokeStyle = ownerColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = hexToRgba(ownerColor, 0.4);
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
        } else {
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Type indicator
        if (this.typeData.icon) {
            ctx.font = `${this.size * 0.4}px system-ui`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.typeData.icon, this.x, this.y - this.size * 0.5);
        }
        
        // SELECTION RING - Enhanced for multi-select
        if (this.selected) {
            const selectionPulse = (Math.sin(Date.now() / 150) + 1) / 2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 + selectionPulse * 0.3})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Selection glow
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + selectionPulse * 0.2})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // Selection number indicator
            const selIndex = game.selectedPlanets.indexOf(this) + 1;
            if (game.selectedPlanets.length > 1) {
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`#${selIndex}`, this.x + this.size + 20, this.y - this.size - 5);
            }
        }
        
        // Incoming attack warning
        if (this.incomingAttacks.length > 0 && this.owner === PLAYER) {
            const warningPulse = (Math.sin(Date.now() / 100) + 1) / 2;
            ctx.strokeStyle = `rgba(255, 100, 100, ${0.3 + warningPulse * 0.5})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 25, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#f44';
            ctx.font = 'bold 12px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`‚ö†Ô∏è ${this.incomingAttacks.length}`, this.x, this.y - this.size - 30);
        }
        
        // Shield effect
        if (this.shielded) {
            const shieldAlpha = 0.3 + Math.sin(this.pulsePhase * 3) * 0.1;
            ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 18, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // EMP effect
        if (this.empTime > 0 && this.owner === ENEMY) {
            ctx.strokeStyle = 'rgba(255, 240, 0, 0.53)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 10, this.pulsePhase, this.pulsePhase + Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Orbiting particles
        const orbitColor = COLORS[this.owner].particle;
        ctx.fillStyle = orbitColor;
        for (const p of this.orbitParticles) {
            const px = this.x + Math.cos(p.angle) * p.distance;
            const py = this.y + Math.sin(p.angle) * p.distance;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Unit count
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.max(14, this.size / 3)}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(Math.floor(this.units), this.x, this.y);
        
        // Production rate indicator (small text showing rate)
        if (this.owner !== NEUTRAL && this.type !== 'blackhole') {
            const rate = this.productionRate.toFixed(1);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '10px system-ui';
            ctx.fillText(`+${rate}/s`, this.x, this.y + this.size * 0.4);
        }
        
        // Ownership label
        if (this.owner === PLAYER) {
            ctx.fillStyle = COLORS[PLAYER].main;
            ctx.font = 'bold 10px system-ui';
            ctx.fillText('YOU', this.x, this.y + this.size + 18);
        } else if (this.owner === ENEMY) {
            ctx.fillStyle = COLORS[ENEMY].main;
            ctx.font = 'bold 10px system-ui';
            ctx.fillText('AI', this.x, this.y + this.size + 18);
        }
    }
    
    containsPoint(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return Math.sqrt(dx * dx + dy * dy) <= this.size + 20;
    }
}

// Flying particle
class FlyingParticle {
    constructor(x, y, targetPlanet, owner) {
        this.x = x;
        this.y = y;
        this.target = targetPlanet;
        this.owner = owner;
        this.baseSpeed = 150;
        this.trail = [];
        this.stealthTime = 0; // Time remaining in stealth
    }
    
    get speed() {
        let spd = this.baseSpeed;
        if (this.owner === PLAYER && abilities.boost.active) spd *= 3;
        return spd;
    }
    
    update(dt) {
        // Update stealth timer
        if (this.stealthTime > 0) {
            this.stealthTime -= dt;
        }

        let targetX = this.target.x;
        let targetY = this.target.y;

        // Check for black hole pull
        for (const planet of planets) {
            if (planet.type === 'blackhole') {
                const dx = planet.x - this.x;
                const dy = planet.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200) {
                    const pullForce = (200 - dist) / 200 * 2;
                    this.x += (dx / dist) * pullForce;
                    this.y += (dy / dist) * pullForce;
                }
                
                if (dist < planet.size) {
                    effects.push(new Effect('explosion', this.x, this.y, { duration: 0.3 }));
                    return false;
                }
            }
        }
        
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < this.target.size) {
            if (this.target.type === 'blackhole') {
                effects.push(new Effect('explosion', this.x, this.y, { duration: 0.3 }));
                return false;
            }
            
            if (this.target.owner === this.owner) {
                this.target.units += 1;
            } else {
                const damage = 1 / this.target.defenseMult;
                this.target.units -= damage;
                
                if (this.target.units <= 0) {
                    const prevOwner = this.target.owner;
                    this.target.owner = this.owner;
                    this.target.units = 1;

                    // Track capture stats and play sounds
                    if (this.owner === PLAYER) {
                        playerStats.planetsConquered++;
                        playSound('capture');

                        // Check if all planets owned for daily challenge
                        if (planets.every(p => p.owner === PLAYER)) {
                            currentGameStats.allPlanetsOwned = true;
                        }
                    } else if (prevOwner === PLAYER) {
                        playerStats.planetsLost++;
                        currentGameStats.perfectWin = false;
                        currentGameStats.planetsLostThisGame++;
                        playSound('lose');
                    }

                    effects.push(new Effect('capture', this.target.x, this.target.y, {
                        duration: 0.8,
                        radius: this.target.size,
                        color: COLORS[this.owner].main
                    }));

                    showFloatText(this.target.x, this.target.y, 'CAPTURED!', COLORS[this.owner].main);
                }
            }
            return false;
        }
        
        this.trail.push({ x: this.x, y: this.y, age: 0 });
        if (this.trail.length > 10) this.trail.shift();
        for (const t of this.trail) t.age += dt;
        
        this.x += (dx / dist) * this.speed * dt;
        this.y += (dy / dist) * this.speed * dt;
        
        this.x += Math.sin(Date.now() / 100 + this.x) * 0.3;
        this.y += Math.cos(Date.now() / 100 + this.y) * 0.3;
        
        return true;
    }
    
    draw() {
        const color = COLORS[this.owner];
        const isStealthed = this.stealthTime > 0 && this.owner === PLAYER;

        // If stealthed, draw with ghostly effect
        const stealthAlpha = isStealthed ? 0.3 : 1;

        for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            const alpha = (1 - i / this.trail.length) * 0.5 * stealthAlpha;
            ctx.fillStyle = hexToRgba(color.particle, alpha);
            ctx.beginPath();
            ctx.arc(t.x, t.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        if (this.owner === PLAYER && abilities.boost.active) {
            ctx.fillStyle = `rgba(255, 240, 0, ${0.5 * stealthAlpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
            ctx.fill();
        }

        // Stealth glow effect
        if (isStealthed) {
            ctx.fillStyle = 'rgba(100, 50, 150, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = hexToRgba(color.particle, stealthAlpha);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = hexToRgba(color.particle, 0.25 * stealthAlpha);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Background particle
class BgParticle {
    constructor() { this.reset(); }

    reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.vx = (Math.random() - 0.5) * 15;
        this.vy = (Math.random() - 0.5) * 15;
        this.size = Math.random() * 1.5 + 0.5;
        this.alpha = Math.random() * 0.3 + 0.1;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        if (this.x < 0 || this.x > W || this.y < 0 || this.y > H) this.reset();
    }

    draw() {
        ctx.fillStyle = `rgba(100, 150, 200, ${this.alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Comet class for comet showers
class Comet {
    constructor() {
        // Random direction: can come from any edge
        const side = Math.floor(Math.random() * 4);
        const speed = 400 + Math.random() * 300;

        switch(side) {
            case 0: // From top
                this.x = Math.random() * W;
                this.y = -50;
                this.vx = (Math.random() - 0.5) * 200;
                this.vy = speed;
                break;
            case 1: // From bottom
                this.x = Math.random() * W;
                this.y = H + 50;
                this.vx = (Math.random() - 0.5) * 200;
                this.vy = -speed;
                break;
            case 2: // From left
                this.x = -50;
                this.y = Math.random() * H;
                this.vx = speed;
                this.vy = (Math.random() - 0.5) * 200;
                break;
            case 3: // From right
                this.x = W + 50;
                this.y = Math.random() * H;
                this.vx = -speed;
                this.vy = (Math.random() - 0.5) * 200;
                break;
        }

        this.size = 8 + Math.random() * 6;
        this.trail = [];
        this.hitRadius = 30;
    }

    update(dt) {
        // Add trail
        this.trail.push({ x: this.x, y: this.y, age: 0 });
        if (this.trail.length > 20) this.trail.shift();
        for (const t of this.trail) t.age += dt;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Check collision with flying particles (not stealthed ones from player perspective)
        for (let i = flyingParticles.length - 1; i >= 0; i--) {
            const p = flyingParticles[i];
            const dx = p.x - this.x;
            const dy = p.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.hitRadius) {
                // Destroy the particle
                effects.push(new Effect('explosion', p.x, p.y, { duration: 0.3 }));
                flyingParticles.splice(i, 1);
            }
        }

        // Return false when off screen
        return !(this.x < -100 || this.x > W + 100 || this.y < -100 || this.y > H + 100);
    }

    draw() {
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            const alpha = (1 - i / this.trail.length) * 0.6;
            const size = this.size * (1 - i / this.trail.length);

            const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size);
            gradient.addColorStop(0, `rgba(255, 200, 100, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(255, 100, 50, ${alpha * 0.5})`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw comet head
        const headGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
        headGradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
        headGradient.addColorStop(0.3, 'rgba(255, 200, 100, 0.8)');
        headGradient.addColorStop(0.6, 'rgba(255, 100, 50, 0.4)');
        headGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = headGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();

        // Bright core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Spawn comet shower
function spawnCometShower() {
    const numComets = 5 + Math.floor(Math.random() * 8);
    showFloatText(W / 2, 100, '‚òÑÔ∏è COMET SHOWER!', '#ff8844');
    playSound('comet');

    for (let i = 0; i < numComets; i++) {
        setTimeout(() => {
            comets.push(new Comet());
        }, i * 150);
    }
}

// Harvest mode particle
class HarvestParticle {
    constructor() {
        this.x = Math.random() * W;
        this.y = 100 + Math.random() * (H - 200);
        this.vx = (Math.random() - 0.5) * 60;
        this.vy = (Math.random() - 0.5) * 60;
        this.size = 6;
        this.grabbed = false;
        this.grabbedBy = null;
        this.targetPlanet = null;
        this.collected = false;
        this.pulsePhase = Math.random() * Math.PI * 2;
    }
    
    update(dt) {
        this.pulsePhase += dt * 5;
        
        if (this.collected) return false;
        
        if (this.grabbed && this.targetPlanet) {
            const dx = this.targetPlanet.x - this.x;
            const dy = this.targetPlanet.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < this.targetPlanet.size) {
                this.targetPlanet.units += 1;
                this.collected = true;
                effects.push(new Effect('capture', this.x, this.y, {
                    duration: 0.3,
                    radius: 10,
                    color: COLORS[this.grabbedBy].main
                }));
                return false;
            }
            
            const speed = 300;
            this.x += (dx / dist) * speed * dt;
            this.y += (dy / dist) * speed * dt;
        } else {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            
            if (this.x < 50 || this.x > W - 50) this.vx *= -1;
            if (this.y < 100 || this.y > H - 100) this.vy *= -1;
            
            this.x = Math.max(50, Math.min(W - 50, this.x));
            this.y = Math.max(100, Math.min(H - 100, this.y));
            
            this.vx += (Math.random() - 0.5) * 20 * dt;
            this.vy += (Math.random() - 0.5) * 20 * dt;
            
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            if (speed > 80) {
                this.vx = (this.vx / speed) * 80;
                this.vy = (this.vy / speed) * 80;
            }
        }
        
        return true;
    }
    
    draw() {
        if (this.collected) return;
        
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
        
        const glowColor = this.grabbed ? COLORS[this.grabbedBy].main : '#ffffff';
        ctx.fillStyle = hexToRgba(glowColor, 0.3);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2 * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        const coreColor = this.grabbed ? COLORS[this.grabbedBy].main : '#ffffff';
        ctx.fillStyle = coreColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.grabbed && this.targetPlanet) {
            ctx.strokeStyle = hexToRgba(COLORS[this.grabbedBy].main, 0.5);
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.targetPlanet.x, this.targetPlanet.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    containsPoint(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return Math.sqrt(dx * dx + dy * dy) <= this.size * 3;
    }
}

function showFloatText(x, y, text, color) {
    const el = document.createElement('div');
    el.className = 'float-text';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    el.textContent = text;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function updateSelectionIndicator() {
    const indicator = document.getElementById('selectionIndicator');
    if (game.selectedPlanets.length > 0) {
        indicator.classList.remove('hidden');
        const totalUnits = game.selectedPlanets.reduce((sum, p) => sum + Math.floor(p.units), 0);
        indicator.textContent = `${game.selectedPlanets.length} planet${game.selectedPlanets.length > 1 ? 's' : ''} selected (${totalUnits} units)`;
    } else {
        indicator.classList.add('hidden');
    }
}

function selectAllPlayerPlanets() {
    game.selectedPlanets = planets.filter(p => p.owner === PLAYER && p.units >= 1);
    
    // Visual feedback
    for (const planet of game.selectedPlanets) {
        effects.push(new Effect('selectAll', planet.x, planet.y, {
            duration: 0.4,
            radius: planet.size
        }));
    }
    
    showFloatText(W / 2, H / 2, `ALL ${game.selectedPlanets.length} PLANETS SELECTED!`, '#0ff');
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = `${game.selectedPlanets.length} planets selected - tap target`;
}

function togglePlanetSelection(planet) {
    const index = game.selectedPlanets.indexOf(planet);
    if (index >= 0) {
        // Deselect
        game.selectedPlanets.splice(index, 1);
    } else {
        // Select
        game.selectedPlanets.push(planet);
        playSound('select');
    }
    updateSelectionIndicator();

    if (game.selectedPlanets.length > 0) {
        document.getElementById('gameStatus').textContent = `${game.selectedPlanets.length} planet${game.selectedPlanets.length > 1 ? 's' : ''} selected - tap target`;
    } else {
        document.getElementById('gameStatus').textContent = 'Select your planet';
    }
}

function generateLevel() {
    const settings = DIFFICULTY[game.difficulty];
    const numPlanets = settings.planets + Math.floor(game.level / 2);

    planets = [];
    flyingParticles = [];
    harvestParticles = [];
    effects = [];
    wormholePairs = [];
    comets = [];
    lastCometShower = Date.now(); // Reset comet timer
    game.selectedPlanets = [];
    selectedHarvestParticle = null;

    for (const key in abilities) {
        abilities[key].cooldown = 0;
        abilities[key].active = false;
        if (abilities[key].targetPlanet) abilities[key].targetPlanet = null;
    }

    // Show/hide stealth button based on feature toggle
    document.getElementById('stealthBtn').style.display = game.features.stealth ? 'flex' : 'none';
    
    const positions = [];
    const minDist = 130;
    const margin = 80;
    
    for (let i = 0; i < numPlanets; i++) {
        let x, y, valid, attempts = 0;
        
        do {
            x = margin + Math.random() * (W - margin * 2);
            y = margin + 70 + Math.random() * (H - margin * 2 - 160);
            valid = true;
            
            for (const pos of positions) {
                if (Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2) < minDist) {
                    valid = false;
                    break;
                }
            }
            attempts++;
        } while (!valid && attempts < 100);
        
        positions.push({ x, y });
    }
    
    const specialTypes = ['factory', 'fortress', 'wormhole', 'wormhole', 'blackhole'];
    const numSpecials = Math.min(settings.specialPlanets, Math.max(0, positions.length - 2));
    const specialIndices = [];
    
    const availableIndices = positions.length - 2;
    if (availableIndices > 0) {
        while (specialIndices.length < numSpecials) {
            const idx = 1 + Math.floor(Math.random() * availableIndices);
            if (!specialIndices.includes(idx)) specialIndices.push(idx);
        }
    }
    
    let wormholeCount = 0;
    const wormholePlanets = [];
    
    const startUnits = game.mode === 'harvest' ? 5 : settings.startingUnits;
    
    for (let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        const size = 30 + Math.random() * 35;
        let owner = NEUTRAL;
        let units = 10 + Math.random() * 15;
        let type = 'normal';
        
        if (i === 0) {
            owner = PLAYER;
            units = startUnits;
        } else if (i === positions.length - 1) {
            owner = ENEMY;
            units = startUnits;
        } else if (specialIndices.includes(i)) {
            type = specialTypes[specialIndices.indexOf(i) % specialTypes.length];
            if (type === 'blackhole') {
                units = 0;
                owner = NEUTRAL;
            }
        }
        
        const planet = new Planet(pos.x, pos.y, size, owner, units, type);
        planets.push(planet);
        
        if (type === 'wormhole') {
            wormholePlanets.push(planet);
        }
    }
    
    for (let i = 0; i < wormholePlanets.length - 1; i += 2) {
        if (wormholePlanets[i + 1]) {
            wormholePlanets[i].wormholePartner = wormholePlanets[i + 1];
            wormholePlanets[i + 1].wormholePartner = wormholePlanets[i];
        }
    }
    
    if (game.mode === 'harvest') {
        for (let i = 0; i < HARVEST_PARTICLE_COUNT; i++) {
            harvestParticles.push(new HarvestParticle());
        }
        game.state = 'harvest';
        document.getElementById('harvestHud').classList.remove('hidden');
        document.getElementById('harvestProgress').classList.remove('hidden');
        document.getElementById('abilitiesBar').classList.add('hidden');
        document.getElementById('sendPercent').classList.add('hidden');
        updateHarvestUI();
    } else {
        game.state = 'playing';
        document.getElementById('harvestHud').classList.add('hidden');
        document.getElementById('harvestProgress').classList.add('hidden');
        document.getElementById('abilitiesBar').classList.remove('hidden');
        document.getElementById('sendPercent').classList.remove('hidden');
    }
    
    document.getElementById('levelInfo').textContent = `Level ${game.level} ‚Ä¢ ${game.difficulty.toUpperCase()} ‚Ä¢ ${game.mode.toUpperCase()}`;
    updateSelectionIndicator();
}

function initBgParticles() {
    bgParticles = [];
    for (let i = 0; i < 80; i++) {
        bgParticles.push(new BgParticle());
    }
}

let selectedHarvestParticle = null;
let playerHarvested = 0;
let enemyHarvested = 0;
let lastAIHarvest = 0;

function updateHarvestUI() {
    const remaining = harvestParticles.filter(p => !p.grabbed && !p.collected).length;
    const total = HARVEST_PARTICLE_COUNT;
    
    document.getElementById('playerHarvested').textContent = playerHarvested;
    document.getElementById('enemyHarvested').textContent = enemyHarvested;
    document.getElementById('remainingParticles').textContent = remaining + ' remaining';
    document.getElementById('playerHarvestBar').style.width = (playerHarvested / total * 100) + '%';
    document.getElementById('enemyHarvestBar').style.width = (enemyHarvested / total * 100) + '%';
}

function updateHarvestAI(dt) {
    const settings = DIFFICULTY[game.difficulty];
    const now = Date.now();
    
    const grabInterval = 800 / settings.aiSpeed;
    if (now - lastAIHarvest < grabInterval) return;
    lastAIHarvest = now;
    
    const available = harvestParticles.filter(p => !p.grabbed && !p.collected);
    if (available.length === 0) return;
    
    const particle = available[Math.floor(Math.random() * available.length)];
    
    const enemyPlanets = planets.filter(p => p.owner === ENEMY);
    if (enemyPlanets.length === 0) return;
    
    let targetPlanet;
    if (Math.random() < 0.7) {
        targetPlanet = enemyPlanets.reduce((a, b) => a.size > b.size ? a : b);
    } else {
        targetPlanet = enemyPlanets[Math.floor(Math.random() * enemyPlanets.length)];
    }
    
    particle.grabbed = true;
    particle.grabbedBy = ENEMY;
    particle.targetPlanet = targetPlanet;
    enemyHarvested++;
    updateHarvestUI();
}

function checkHarvestComplete() {
    const remaining = harvestParticles.filter(p => !p.collected).length;
    
    if (remaining === 0) {
        game.state = 'playing';
        document.getElementById('harvestHud').classList.add('hidden');
        document.getElementById('harvestProgress').classList.add('hidden');
        document.getElementById('abilitiesBar').classList.remove('hidden');
        document.getElementById('sendPercent').classList.remove('hidden');
        document.getElementById('gameStatus').textContent = 'Battle begins! Select your planet';
        showFloatText(W / 2, H / 2, '‚öîÔ∏è BATTLE BEGINS!', '#fff');
    }
}

function sendUnits(from, to, percent) {
    const numToSend = Math.floor(from.units * (percent / 100));
    if (numToSend < 1) return;
    
    from.units -= numToSend;
    
    let spawnPlanet = from;
    if (from.type === 'wormhole' && from.wormholePartner) {
        spawnPlanet = from.wormholePartner;
        effects.push(new Effect('wormhole', from.x, from.y, { duration: 0.5 }));
        effects.push(new Effect('wormhole', spawnPlanet.x, spawnPlanet.y, { duration: 0.5 }));
    }
    
    for (let i = 0; i < numToSend; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = spawnPlanet.size + Math.random() * 15;
        const x = spawnPlanet.x + Math.cos(angle) * dist;
        const y = spawnPlanet.y + Math.sin(angle) * dist;
        
        setTimeout(() => {
            flyingParticles.push(new FlyingParticle(x, y, to, from.owner));
        }, i * 25);
    }
}

// Unified attack from all selected planets
function sendUnifiedAttack(target, percent) {
    if (game.selectedPlanets.length === 0) return;

    playSound('attack');

    // Track early attack for daily challenge
    if (currentGameStats.firstAttackTime === null) {
        currentGameStats.firstAttackTime = (Date.now() - currentGameStats.startTime) / 1000;
        if (currentGameStats.firstAttackTime < 30) {
            currentGameStats.noEarlyAttack = false;
        }
    }

    for (const planet of game.selectedPlanets) {
        if (planet !== target && planet.units >= 1) {
            sendUnits(planet, target, percent);
        }
    }

    // Clear selection after attack
    game.selectedPlanets = [];
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

let lastAIAction = 0;

function updateAI(dt) {
    const settings = DIFFICULTY[game.difficulty];
    const now = Date.now();
    
    if (now - lastAIAction < 800 / settings.aiSpeed) return;
    lastAIAction = now;
    
    const aiPlanets = planets.filter(p => p.owner === ENEMY && p.units > 8);
    if (aiPlanets.length === 0) return;
    
    if (Math.random() > settings.aiAggression) return;
    
    const source = aiPlanets[Math.floor(Math.random() * aiPlanets.length)];
    
    let bestTarget = null;
    let bestScore = -Infinity;
    
    for (const planet of planets) {
        if (planet === source || planet.type === 'blackhole') continue;
        
        const dist = Math.sqrt((planet.x - source.x) ** 2 + (planet.y - source.y) ** 2);
        let score = 0;
        
        if (planet.owner === PLAYER) {
            score = 100 - planet.units * planet.defenseMult - dist / 15;
            if (planet.shielded) score -= 200;
        } else if (planet.owner === NEUTRAL) {
            score = 60 - planet.units - dist / 8;
            if (planet.type === 'factory') score += 30;
            if (planet.type === 'fortress') score += 20;
        } else {
            score = -100;
        }
        
        if (planet.type === 'wormhole' && planet.owner !== ENEMY) score += 25;
        
        if (score > bestScore) {
            bestScore = score;
            bestTarget = planet;
        }
    }
    
    if (bestTarget && bestScore > -30) {
        let percent = 50;
        if (bestTarget.owner === PLAYER && bestTarget.units < source.units * 0.4) percent = 80;
        if (bestTarget.owner === NEUTRAL) percent = Math.min(70, (bestTarget.units + 5) / source.units * 100);
        
        sendUnits(source, bestTarget, percent);
    }
}

function updateAbilities(dt) {
    for (const key in abilities) {
        const ab = abilities[key];
        
        if (ab.cooldown > 0) ab.cooldown -= dt;
        
        if (ab.active && ab.activeTime > 0) {
            ab.activeTime -= dt;
            if (ab.activeTime <= 0) {
                ab.active = false;
            }
        }
        
        const btn = document.querySelector(`[data-ability="${key}"]`);
        if (btn) {
            const overlay = btn.querySelector('.cooldown-overlay');
            if (ab.cooldown > 0) {
                btn.classList.add('cooldown');
                overlay.style.height = (ab.cooldown / ab.maxCooldown * 100) + '%';
            } else {
                btn.classList.remove('cooldown');
                overlay.style.height = '0%';
            }
            
            btn.classList.toggle('active', ab.active || game.activeAbility === key);
        }
    }
    
    if (abilities.shield.targetPlanet) {
        if (abilities.shield.targetPlanet.shieldTime <= 0) {
            abilities.shield.targetPlanet = null;
        }
    }
}

function activateAbility(abilityName) {
    const ab = abilities[abilityName];
    if (ab.cooldown > 0) return;

    // Stealth requires the feature to be enabled
    if (abilityName === 'stealth' && !game.features.stealth) return;

    // Track ability usage
    playerStats.abilitiesUsed++;
    if (currentGameStats.abilitiesUsedTypes) {
        currentGameStats.abilitiesUsedTypes.add(abilityName);
    }
    if (abilityName === 'nuke') {
        currentGameStats.nukesUsed = (currentGameStats.nukesUsed || 0) + 1;
    }

    playSound('ability');

    switch (abilityName) {
        case 'boost':
            ab.active = true;
            ab.activeTime = ab.duration;
            ab.cooldown = ab.maxCooldown;
            showFloatText(W / 2, H / 2, '‚ö° BOOST ACTIVATED!', '#ff0');
            break;

        case 'stealth':
            ab.active = true;
            ab.activeTime = ab.duration;
            ab.cooldown = ab.maxCooldown;
            // Apply stealth to all current player flying particles
            for (const p of flyingParticles) {
                if (p.owner === PLAYER) {
                    p.stealthTime = ab.duration;
                }
            }
            showFloatText(W / 2, H / 2, 'üëª STEALTH ACTIVATED!', '#a0a');
            break;

        case 'shield':
        case 'nuke':
        case 'emp':
            game.activeAbility = abilityName;
            document.getElementById('gameStatus').textContent = `Select target for ${abilityName.toUpperCase()}`;
            break;
    }
}

function useAbilityOnTarget(planet) {
    const abilityName = game.activeAbility;
    const ab = abilities[abilityName];
    
    switch (abilityName) {
        case 'shield':
            if (planet.owner !== PLAYER) {
                showFloatText(planet.x, planet.y, 'Must target your planet!', '#f44');
                return;
            }
            planet.shielded = true;
            planet.shieldTime = ab.duration;
            ab.targetPlanet = planet;
            ab.cooldown = ab.maxCooldown;
            showFloatText(planet.x, planet.y, 'üõ°Ô∏è SHIELDED!', '#4af');
            break;
            
        case 'emp':
            if (planet.owner !== ENEMY) {
                showFloatText(planet.x, planet.y, 'Must target enemy!', '#f44');
                return;
            }
            for (const p of planets) {
                if (p.owner === ENEMY) {
                    p.empTime = ab.duration;
                }
            }
            ab.cooldown = ab.maxCooldown;
            effects.push(new Effect('explosion', planet.x, planet.y, { duration: 0.5 }));
            showFloatText(planet.x, planet.y, 'üí• EMP!', '#ff0');
            break;
            
        case 'nuke':
            if (planet.owner === PLAYER || planet.type === 'blackhole') {
                showFloatText(planet.x, planet.y, "Can't nuke that!", '#f44');
                return;
            }
            const destroyed = Math.floor(planet.units * 0.5);
            planet.units -= destroyed;
            ab.cooldown = ab.maxCooldown;
            effects.push(new Effect('explosion', planet.x, planet.y, { duration: 0.6 }));
            showFloatText(planet.x, planet.y, `‚ò¢Ô∏è -${destroyed}`, '#f84');
            break;
    }
    
    game.activeAbility = null;
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

function checkWinCondition() {
    const playerPlanets = planets.filter(p => p.owner === PLAYER).length;
    const enemyPlanets = planets.filter(p => p.owner === ENEMY).length;
    const playerFlying = flyingParticles.filter(p => p.owner === PLAYER).length;
    const enemyFlying = flyingParticles.filter(p => p.owner === ENEMY).length;
    
    if (enemyPlanets === 0 && enemyFlying === 0) {
        endGame(true);
    } else if (playerPlanets === 0 && playerFlying === 0) {
        endGame(false);
    }
}

function endGame(victory) {
    game.state = 'ended';

    // Update game stats
    currentGameStats.gameTime = (Date.now() - currentGameStats.startTime) / 1000;
    currentGameStats.won = victory;
    currentGameStats.abilitiesUsedTypes = currentGameStats.abilitiesUsedTypes.size;

    // Update player stats
    playerStats.gamesPlayed++;
    playerStats.totalPlayTime += currentGameStats.gameTime;

    if (victory) {
        playerStats.gamesWon++;
        playerStats.currentStreak++;
        if (playerStats.currentStreak > playerStats.bestStreak) {
            playerStats.bestStreak = playerStats.currentStreak;
        }
        if (game.level > playerStats.highestLevel) {
            playerStats.highestLevel = game.level;
        }
        if (currentGameStats.perfectWin) {
            playerStats.perfectWins++;
        }
        if (!playerStats.fastestWin || currentGameStats.gameTime < playerStats.fastestWin) {
            playerStats.fastestWin = currentGameStats.gameTime;
        }
        playSound('victory');
    } else {
        playerStats.gamesLost++;
        playerStats.currentStreak = 0;
        playSound('defeat');
    }

    // Save features for next session
    playerStats.features = { ...game.features };
    saveStats();

    // Check daily challenges
    checkDailyChallenges();
    updateDailyChallengesUI();

    const screen = document.getElementById('resultScreen');
    const title = document.getElementById('resultTitle');
    const text = document.getElementById('resultText');

    if (victory) {
        screen.className = 'result-screen victory';
        title.textContent = 'VICTORY!';
        text.textContent = `Level ${game.level} conquered!`;
        game.level++;
    } else {
        screen.className = 'result-screen defeat';
        title.textContent = 'DEFEAT';
        text.textContent = 'The enemy has won...';
    }

    screen.classList.remove('hidden');
}

function startGame(difficulty) {
    game.difficulty = difficulty;
    game.level = 1;
    game.activeAbility = null;
    game.selectedPlanets = [];
    game.paused = false;
    playerHarvested = 0;
    enemyHarvested = 0;

    playSound('click');
    initAudio();

    document.getElementById('menu').classList.add('hidden');
    document.getElementById('resultScreen').classList.add('hidden');
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');

    resetCurrentGameStats();
    generateLevel();
}

function pauseGame() {
    if (game.state !== 'playing' && game.state !== 'harvest') return;
    game.paused = true;
    document.getElementById('pauseMenu').classList.remove('hidden');
    document.getElementById('pauseBtn').classList.add('hidden');

    // Sync feature toggles in pause menu
    syncPauseFeatureToggles();
}

function resumeGame() {
    game.paused = false;
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');
}

function restartLevel() {
    game.paused = false;
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');
    generateLevel();
}

function quitToMenu() {
    game.paused = false;
    game.state = 'menu';
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');

    // Sync main menu feature toggles
    syncMenuFeatureToggles();
}

function syncPauseFeatureToggles() {
    document.querySelectorAll('#pauseFeatureToggles .feature-toggle').forEach(toggle => {
        const feature = toggle.dataset.feature;
        toggle.classList.toggle('active', game.features[feature]);
    });
}

function syncMenuFeatureToggles() {
    document.querySelectorAll('.menu .feature-toggle').forEach(toggle => {
        const feature = toggle.dataset.feature;
        toggle.classList.toggle('active', game.features[feature]);
    });
}

function togglePause() {
    if (game.state !== 'playing' && game.state !== 'harvest') return;

    if (game.paused) {
        resumeGame();
    } else {
        pauseGame();
    }
}

function updateStats() {
    let playerUnits = 0, enemyUnits = 0;
    
    for (const p of planets) {
        if (p.owner === PLAYER) playerUnits += Math.floor(p.units);
        if (p.owner === ENEMY) enemyUnits += Math.floor(p.units);
    }
    
    playerUnits += flyingParticles.filter(p => p.owner === PLAYER).length;
    enemyUnits += flyingParticles.filter(p => p.owner === ENEMY).length;
    
    document.getElementById('playerStats').textContent = playerUnits;
    document.getElementById('enemyStats').textContent = enemyUnits;
}

function drawWormholeConnections() {
    for (const planet of planets) {
        if (planet.type === 'wormhole' && planet.wormholePartner) {
            const partner = planet.wormholePartner;
            
            if (planets.indexOf(planet) > planets.indexOf(partner)) continue;
            
            ctx.strokeStyle = 'rgba(170, 68, 170, 0.27)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 10]);
            ctx.beginPath();
            ctx.moveTo(planet.x, planet.y);
            ctx.lineTo(partner.x, partner.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}

// Draw attack preview lines from all selected planets
function drawAttackPreviewLines(targetX, targetY) {
    for (const planet of game.selectedPlanets) {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(planet.x, planet.y);
        ctx.lineTo(targetX, targetY);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Arrow at target
    if (game.selectedPlanets.length > 0) {
        const centerX = game.selectedPlanets.reduce((s, p) => s + p.x, 0) / game.selectedPlanets.length;
        const centerY = game.selectedPlanets.reduce((s, p) => s + p.y, 0) / game.selectedPlanets.length;
        const angle = Math.atan2(targetY - centerY, targetX - centerX);
        
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.moveTo(targetX, targetY);
        ctx.lineTo(targetX - 15 * Math.cos(angle - 0.4), targetY - 15 * Math.sin(angle - 0.4));
        ctx.lineTo(targetX - 15 * Math.cos(angle + 0.4), targetY - 15 * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
    }
}

// Fog of War - using offscreen canvas
let fogCanvas = null;
let fogCtx = null;

function initFogCanvas() {
    fogCanvas = document.createElement('canvas');
    fogCanvas.width = W;
    fogCanvas.height = H;
    fogCtx = fogCanvas.getContext('2d');
}

function drawFogOfWar() {
    if (!game.features.fog) return;

    // Initialize fog canvas if needed
    if (!fogCanvas || fogCanvas.width !== W || fogCanvas.height !== H) {
        initFogCanvas();
    }

    // Clear fog canvas and fill with dark fog
    fogCtx.clearRect(0, 0, W, H);
    fogCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    fogCtx.fillRect(0, 0, W, H);

    // Use destination-out on the FOG canvas to cut visibility holes
    fogCtx.globalCompositeOperation = 'destination-out';

    // Cut visibility around player planets
    for (const planet of planets) {
        if (planet.owner === PLAYER) {
            const visRadius = planet.size * 6;
            const gradient = fogCtx.createRadialGradient(
                planet.x, planet.y, planet.size * 0.5,
                planet.x, planet.y, visRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            fogCtx.fillStyle = gradient;
            fogCtx.beginPath();
            fogCtx.arc(planet.x, planet.y, visRadius, 0, Math.PI * 2);
            fogCtx.fill();
        }
    }

    // Also reveal around player's flying particles
    for (const p of flyingParticles) {
        if (p.owner === PLAYER) {
            const visRadius = 80;
            const gradient = fogCtx.createRadialGradient(
                p.x, p.y, 5,
                p.x, p.y, visRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            fogCtx.fillStyle = gradient;
            fogCtx.beginPath();
            fogCtx.arc(p.x, p.y, visRadius, 0, Math.PI * 2);
            fogCtx.fill();
        }
    }

    // Reset composite operation
    fogCtx.globalCompositeOperation = 'source-over';

    // Draw the fog layer onto the main canvas
    ctx.drawImage(fogCanvas, 0, 0);
}

// Check if a point is visible to the player (for fog of war)
function isVisibleToPlayer(x, y) {
    if (!game.features.fog) return true;

    for (const planet of planets) {
        if (planet.owner === PLAYER) {
            const dx = x - planet.x;
            const dy = y - planet.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < planet.size * 5) return true;
        }
    }

    for (const p of flyingParticles) {
        if (p.owner === PLAYER) {
            const dx = x - p.x;
            const dy = y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 60) return true;
        }
    }

    return false;
}

// Game loop
let lastTime = 0;
let currentTouch = null;

function animate(time) {
    const realDt = Math.min((time - lastTime) / 1000, 0.1);
    const dt = realDt * game.speed;
    lastTime = time;
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    
    for (const p of bgParticles) {
        p.update(realDt);
        p.draw();
    }
    
    if (game.state === 'harvest') {
        // Only update if not paused
        if (!game.paused) {
            harvestParticles = harvestParticles.filter(p => p.update(dt));
            effects = effects.filter(e => e.update(dt));
            updateHarvestAI(dt);
            checkHarvestComplete();
        }

        // Always draw
        for (const planet of planets) planet.draw();
        for (const p of harvestParticles) p.draw();
        for (const e of effects) e.draw();

        if (selectedHarvestParticle && !selectedHarvestParticle.grabbed) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(selectedHarvestParticle.x, selectedHarvestParticle.y, 20, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw pause overlay hint
        if (game.paused) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, W, H);
        }
    }

    if (game.state === 'playing') {
        // Only update if not paused
        if (!game.paused) {
            for (const planet of planets) planet.update(dt);
            flyingParticles = flyingParticles.filter(p => p.update(dt));
            effects = effects.filter(e => e.update(dt));

            // Update comets
            if (game.features.comets) {
                comets = comets.filter(c => c.update(dt));

                // Spawn comet showers periodically
                const now = Date.now();
                if (now - lastCometShower > COMET_SHOWER_INTERVAL) {
                    lastCometShower = now;
                    spawnCometShower();
                }
            }

            updateAI(dt);
            updateAbilities(realDt);
            checkWinCondition();
            updateStats();
        }

        // Always draw
        drawWormholeConnections();

        for (const planet of planets) planet.draw();
        for (const e of effects) e.draw();
        for (const p of flyingParticles) p.draw();

        // Draw comets
        for (const c of comets) c.draw();

        // Attack preview lines when planets are selected and mouse is moving
        if (game.selectedPlanets.length > 0 && currentTouch && !game.paused) {
            drawAttackPreviewLines(currentTouch.x, currentTouch.y);
        }

        // Draw fog of war on top
        drawFogOfWar();

        // Draw pause overlay hint
        if (game.paused) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, W, H);
        }
    }
    
    if (game.state === 'menu' || game.state === 'ended') {
        drawWormholeConnections();
        for (const planet of planets) planet.draw();
    }
    
    requestAnimationFrame(animate);
}

// Input handling with double-click detection
function handleStart(x, y) {
    // Ignore input when paused
    if (game.paused) return;

    const now = Date.now();

    // Harvest mode input
    if (game.state === 'harvest') {
        if (selectedHarvestParticle && !selectedHarvestParticle.grabbed) {
            for (const planet of planets) {
                if (planet.containsPoint(x, y) && planet.owner === PLAYER) {
                    selectedHarvestParticle.grabbed = true;
                    selectedHarvestParticle.grabbedBy = PLAYER;
                    selectedHarvestParticle.targetPlanet = planet;
                    playerHarvested++;
                    updateHarvestUI();
                    selectedHarvestParticle = null;
                    document.getElementById('gameStatus').textContent = 'Tap more particles!';
                    return;
                }
            }
        }
        
        for (const particle of harvestParticles) {
            if (!particle.grabbed && !particle.collected && particle.containsPoint(x, y)) {
                selectedHarvestParticle = particle;
                document.getElementById('gameStatus').textContent = 'Now tap YOUR planet to collect!';
                return;
            }
        }
        
        selectedHarvestParticle = null;
        document.getElementById('gameStatus').textContent = 'Tap particles to grab them!';
        return;
    }
    
    if (game.state !== 'playing') return;
    
    // Check if using ability
    if (game.activeAbility) {
        for (const planet of planets) {
            if (planet.containsPoint(x, y)) {
                useAbilityOnTarget(planet);
                return;
            }
        }
        game.activeAbility = null;
        document.getElementById('gameStatus').textContent = 'Select your planet';
        return;
    }
    
    // Check for planet clicks
    for (const planet of planets) {
        if (planet.containsPoint(x, y)) {
            if (planet.owner === PLAYER) {
                // Check for double-click
                const isDoubleClick = (now - game.lastClickTime < game.doubleClickThreshold) && 
                                      game.lastClickedPlanet === planet;
                
                game.lastClickTime = now;
                game.lastClickedPlanet = planet;
                
                if (isDoubleClick) {
                    // Double-click: Select ALL player planets
                    selectAllPlayerPlanets();
                } else {
                    // Single click: Toggle this planet's selection
                    togglePlanetSelection(planet);
                }
            } else {
                // Clicked on non-player planet: This is a target!
                if (game.selectedPlanets.length > 0) {
                    sendUnifiedAttack(planet, game.sendPercent);
                }
            }
            return;
        }
    }
    
    // Clicked on empty space - clear selection
    game.selectedPlanets = [];
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

function handleEnd(x, y) {
    // Not used for drag anymore, but keep for potential future use
}

function handleMove(x, y) {
    currentTouch = { x, y };
}

// Mouse
canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
canvas.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));

// Touch
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); });
canvas.addEventListener('touchend', e => { e.preventDefault(); if (e.changedTouches.length) handleEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); });

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    // Pause toggle works in playing and harvest states
    if (e.key === 'p' || e.key === 'P') {
        togglePause();
        return;
    }

    // Escape can unpause or clear selection
    if (e.key === 'Escape') {
        if (game.paused) {
            resumeGame();
            return;
        }
        if (game.state === 'playing' || game.state === 'harvest') {
            if (game.activeAbility || game.selectedPlanets.length > 0) {
                game.activeAbility = null;
                game.selectedPlanets = [];
                updateSelectionIndicator();
                document.getElementById('gameStatus').textContent = 'Select your planet';
            } else {
                pauseGame();
            }
        }
        return;
    }

    // Other shortcuts only work when not paused and in playing state
    if (game.state !== 'playing' || game.paused) return;

    if (e.key === '1') activateAbility('boost');
    if (e.key === '2') activateAbility('shield');
    if (e.key === '3') activateAbility('emp');
    if (e.key === '4') activateAbility('nuke');
    if (e.key === '5') activateAbility('stealth');
    if (e.key === 'a' || e.key === 'A') selectAllPlayerPlanets();
});

// UI Events
document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.mode = this.dataset.mode;
        
        document.getElementById('classicInstructions').style.display = game.mode === 'classic' ? 'block' : 'none';
        document.getElementById('harvestInstructions').style.display = game.mode === 'harvest' ? 'block' : 'none';
    });
});

document.querySelectorAll('.diff-btn').forEach(btn => {
    btn.addEventListener('click', () => startGame(btn.dataset.diff));
});

document.getElementById('playAgainBtn').addEventListener('click', () => {
    document.getElementById('resultScreen').classList.add('hidden');
    playerHarvested = 0;
    enemyHarvested = 0;
    generateLevel();
});

document.querySelectorAll('.percent-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.percent-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.sendPercent = parseInt(this.dataset.pct);
    });
});

document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.speed = parseFloat(this.dataset.speed);
    });
});

document.querySelectorAll('.ability-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        activateAbility(this.dataset.ability);
    });
});

// Feature toggles (both main menu and pause menu)
document.querySelectorAll('.feature-toggle').forEach(toggle => {
    toggle.addEventListener('click', function() {
        const feature = this.dataset.feature;
        game.features[feature] = !game.features[feature];

        // Sync all toggles with the same feature
        document.querySelectorAll(`.feature-toggle[data-feature="${feature}"]`).forEach(t => {
            t.classList.toggle('active', game.features[feature]);
        });

        // Update stealth button visibility if toggling stealth
        if (feature === 'stealth') {
            document.getElementById('stealthBtn').style.display = game.features.stealth ? 'flex' : 'none';
        }
    });
});

// Pause button
document.getElementById('pauseBtn').addEventListener('click', pauseGame);

// Pause menu buttons
document.getElementById('resumeBtn').addEventListener('click', resumeGame);
document.getElementById('restartBtn').addEventListener('click', restartLevel);
document.getElementById('quitBtn').addEventListener('click', quitToMenu);

// Sound toggle
document.getElementById('soundToggle').addEventListener('click', function() {
    playerStats.settings.soundEnabled = !playerStats.settings.soundEnabled;
    this.textContent = playerStats.settings.soundEnabled ? 'üîä' : 'üîá';
    this.classList.toggle('muted', !playerStats.settings.soundEnabled);
    saveStats();
    if (playerStats.settings.soundEnabled) {
        initAudio();
        playSound('click');
    }
});

// Stats screen
document.getElementById('statsBtn').addEventListener('click', showStatsScreen);
document.getElementById('statsCloseBtn').addEventListener('click', () => {
    document.getElementById('statsScreen').classList.add('hidden');
});

function showStatsScreen() {
    playSound('click');
    const grid = document.getElementById('statsGrid');
    const stats = [
        { value: playerStats.gamesPlayed, label: 'Games Played' },
        { value: playerStats.gamesWon, label: 'Victories' },
        { value: playerStats.gamesLost, label: 'Defeats' },
        { value: playerStats.gamesPlayed > 0 ? Math.round((playerStats.gamesWon / playerStats.gamesPlayed) * 100) + '%' : '0%', label: 'Win Rate' },
        { value: playerStats.highestLevel, label: 'Highest Level' },
        { value: playerStats.currentStreak, label: 'Current Streak' },
        { value: playerStats.bestStreak, label: 'Best Streak' },
        { value: playerStats.planetsConquered, label: 'Planets Conquered' },
        { value: playerStats.perfectWins, label: 'Perfect Wins' },
        { value: playerStats.abilitiesUsed, label: 'Abilities Used' },
        { value: playerStats.fastestWin ? Math.floor(playerStats.fastestWin) + 's' : '-', label: 'Fastest Win' },
        { value: Math.floor(playerStats.totalPlayTime / 60) + 'm', label: 'Total Play Time' }
    ];

    grid.innerHTML = stats.map(s => `
        <div class="stat-card">
            <div class="stat-value">${s.value}</div>
            <div class="stat-label">${s.label}</div>
        </div>
    `).join('');

    document.getElementById('statsScreen').classList.remove('hidden');
}

// Daily challenges UI
function updateDailyChallengesUI() {
    const today = getTodayKey();
    const completed = playerStats.dailyChallenges[today]?.completed || [];
    const list = document.getElementById('challengesList');

    list.innerHTML = dailyChallenges.map(c => {
        const isCompleted = completed.includes(c.id);
        return `
            <div class="challenge-item ${isCompleted ? 'completed' : ''}">
                <span class="challenge-icon">${c.title.split(' ')[0]}</span>
                <div class="challenge-info">
                    <div class="challenge-title">${c.title.split(' ').slice(1).join(' ')}</div>
                    <div class="challenge-desc">${c.desc}</div>
                </div>
                ${isCompleted ? '<span class="challenge-check">‚úì</span>' : ''}
            </div>
        `;
    }).join('');
}

// Multiplayer lobby
document.getElementById('multiplayerBtn').addEventListener('click', () => {
    playSound('click');
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('multiplayerLobby').classList.remove('hidden');
    document.getElementById('roomCodeContainer').classList.add('hidden');
    document.getElementById('joinCodeContainer').classList.remove('hidden');
    document.getElementById('lobbyTitle').textContent = 'üåê Multiplayer';
    document.getElementById('lobbyStatus').textContent = 'Host a game or join with a code';
    document.getElementById('joinCodeInput').value = '';
});

document.getElementById('lobbyBackBtn').addEventListener('click', () => {
    playSound('click');
    document.getElementById('multiplayerLobby').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');
    endMultiplayerGame();
});

document.getElementById('lobbyHostBtn').addEventListener('click', () => {
    playSound('click');
    document.getElementById('lobbyStatus').textContent = 'Creating room...';
    hostGame();
});

document.getElementById('lobbyJoinBtn').addEventListener('click', () => {
    const code = document.getElementById('joinCodeInput').value.trim().toUpperCase();
    if (code.length !== 6) {
        showFloatText(W / 2, H / 2, 'Enter 6-character code', '#f44');
        return;
    }
    playSound('click');
    document.getElementById('lobbyStatus').textContent = 'Connecting...';
    joinGame(code);
});

// Initialize audio on first interaction
document.addEventListener('click', function initAudioOnce() {
    initAudio();
    document.removeEventListener('click', initAudioOnce);
}, { once: true });

document.addEventListener('touchstart', function initAudioOnce() {
    initAudio();
    document.removeEventListener('touchstart', initAudioOnce);
}, { once: true });

// Load saved settings
function loadSavedSettings() {
    // Apply saved feature toggles
    game.features = { ...playerStats.features };
    document.querySelectorAll('.feature-toggle').forEach(toggle => {
        const feature = toggle.dataset.feature;
        toggle.classList.toggle('active', game.features[feature]);
    });

    // Apply sound setting
    const soundBtn = document.getElementById('soundToggle');
    soundBtn.textContent = playerStats.settings.soundEnabled ? 'üîä' : 'üîá';
    soundBtn.classList.toggle('muted', !playerStats.settings.soundEnabled);
}

// Init
window.addEventListener('resize', resize);
resize();
initBgParticles();
initDailyChallenges();
updateDailyChallengesUI();
loadSavedSettings();
requestAnimationFrame(animate);
    </script>
</body>
</html>
