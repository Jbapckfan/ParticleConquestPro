<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Particle Conquest Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: system-ui, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            padding-top: max(12px, env(safe-area-inset-top));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            pointer-events: none;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }
        
        .player-dot.player { background: #0ff; box-shadow: 0 0 10px #0ff; }
        .player-dot.enemy { background: #f44; box-shadow: 0 0 10px #f44; }
        
        .player-stats {
            font-size: 22px;
            font-weight: bold;
            color: #fff;
        }
        
        .game-status {
            font-size: 13px;
            color: #888;
            text-align: center;
        }
        
        /* Abilities Bar */
        .abilities-bar {
            position: fixed;
            bottom: calc(80px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            background: rgba(30,30,30,0.9);
            border: 2px solid #444;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .ability-btn:hover:not(.cooldown) {
            border-color: #0ff;
            transform: scale(1.1);
        }
        
        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .ability-btn .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            transition: height 0.1s linear;
        }
        
        .ability-btn .key-hint {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
        
        .ability-btn.active {
            border-color: #0ff;
            box-shadow: 0 0 20px #0ff;
        }
        
        /* Speed Controls */
        .speed-controls {
            position: fixed;
            top: 60px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .speed-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: #222;
            border: 1px solid #444;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .speed-btn.active {
            background: #0af;
            color: #000;
            border-color: #0af;
        }
        
        /* Send Percent */
        .send-percent {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .percent-btn {
            padding: 8px 16px;
            font-size: 13px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .percent-btn.active {
            background: #0af;
            color: #000;
            border-color: #0af;
        }
        
        /* Level Info */
        .level-info {
            position: fixed;
            top: 55px;
            left: 20px;
            color: #555;
            font-size: 12px;
            z-index: 100;
        }
        
        /* Planet Legend */
        .planet-legend {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: max(20px, env(safe-area-inset-left));
            font-size: 10px;
            color: #555;
            z-index: 100;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        
        .legend-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid;
        }
        
        /* Menu */
        .menu {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 20px;
        }
        
        .menu h1 {
            font-size: 42px;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu .subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 30px;
        }
        
        .menu-section {
            margin-bottom: 25px;
            text-align: center;
        }
        
        .menu-section h3 {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 12px;
        }
        
        .difficulty-btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .diff-btn {
            padding: 12px 20px;
            font-size: 14px;
            border: 2px solid #333;
            background: #111;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .diff-btn:hover { transform: scale(1.05); }
        .diff-btn.easy { border-color: #4a4; }
        .diff-btn.easy:hover { background: #4a42; }
        .diff-btn.medium { border-color: #aa4; }
        .diff-btn.medium:hover { background: #aa42; }
        .diff-btn.hard { border-color: #a44; }
        .diff-btn.hard:hover { background: #a442; }
        .diff-btn.insane { border-color: #a4a; }
        .diff-btn.insane:hover { background: #a4a2; }
        
        .mode-btn {
            padding: 12px 25px;
            font-size: 14px;
            border: 2px solid #555;
            background: #111;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 5px;
        }
        
        .mode-btn:hover { transform: scale(1.05); border-color: #888; }
        .mode-btn.active { border-color: #0ff; background: rgba(0, 255, 255, 0.1); }
        
        .harvest-hud {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 90;
        }
        
        .harvest-title {
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 20px #000;
            margin-bottom: 10px;
        }
        
        .harvest-subtitle {
            font-size: 16px;
            color: #aaa;
        }
        
        .harvest-progress {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 100;
        }
        
        .harvest-bar {
            width: 150px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #444;
        }
        
        .harvest-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }
        
        .harvest-bar-fill.player { background: linear-gradient(90deg, #0aa, #0ff); }
        .harvest-bar-fill.enemy { background: linear-gradient(90deg, #a44, #f66); }
        
        .harvest-count {
            font-size: 14px;
            color: #888;
        }
        
        .instructions {
            max-width: 380px;
            text-align: left;
            color: #666;
            font-size: 12px;
            line-height: 1.5;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(255,255,255,0.02);
        }
        
        .instructions h4 {
            color: #888;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: uppercase;
        }
        
        .instructions strong { color: #0ff; }
        .instructions em { color: #f84; font-style: normal; }

        .hidden { display: none !important; }

        /* Feature Toggles */
        .feature-toggles {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .feature-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: #111;
            border: 1px solid #333;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .feature-toggle:hover {
            border-color: #555;
        }

        .feature-toggle.active {
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.1);
        }

        .feature-toggle .toggle-icon {
            font-size: 16px;
        }

        .feature-toggle .toggle-label {
            color: #888;
            font-size: 12px;
        }

        .feature-toggle.active .toggle-label {
            color: #0ff;
        }

        .feature-toggle .toggle-check {
            width: 16px;
            height: 16px;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: transparent;
        }

        .feature-toggle.active .toggle-check {
            border-color: #0ff;
            background: #0ff;
            color: #000;
        }
        
        /* Result Screen */
        .result-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .result-screen h1 {
            font-size: 56px;
            margin-bottom: 15px;
        }
        
        .result-screen.victory h1 { color: #0ff; text-shadow: 0 0 50px #0ff; }
        .result-screen.defeat h1 { color: #f44; text-shadow: 0 0 50px #f44; }
        
        .result-screen p {
            color: #888;
            font-size: 18px;
            margin-bottom: 25px;
        }
        
        .play-again-btn {
            padding: 12px 35px;
            font-size: 16px;
            background: linear-gradient(135deg, #0ff, #0af);
            border: none;
            color: #000;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
        }
        
        /* Floating Combat Text */
        .float-text {
            position: fixed;
            pointer-events: none;
            font-weight: bold;
            font-size: 18px;
            animation: floatUp 1s ease-out forwards;
            z-index: 150;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }
        
        /* Ability tooltip */
        .ability-tooltip {
            position: fixed;
            background: rgba(0,0,0,0.9);
            border: 1px solid #444;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #fff;
            pointer-events: none;
            z-index: 300;
            max-width: 200px;
        }
        
        .ability-tooltip .title {
            color: #0ff;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        /* Selection count indicator */
        .selection-indicator {
            position: fixed;
            bottom: calc(150px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            padding: 8px 20px;
            border-radius: 20px;
            color: #0ff;
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="hud">
        <div class="player-info">
            <div class="player-dot player"></div>
            <div class="player-stats" id="playerStats">0</div>
            <span style="color:#0ff; font-size:12px; margin-left:5px;">YOU</span>
        </div>
        <div class="game-status" id="gameStatus">Select a planet</div>
        <div class="player-info">
            <span style="color:#f44; font-size:12px; margin-right:5px;">AI</span>
            <div class="player-stats" id="enemyStats">0</div>
            <div class="player-dot enemy"></div>
        </div>
    </div>

    <div class="level-info" id="levelInfo">Level 1</div>

    <div class="harvest-hud hidden" id="harvestHud">
        <div class="harvest-title">üåæ HARVEST PHASE</div>
        <div class="harvest-subtitle">Tap particles ‚Üí Tap YOUR planet to collect!</div>
    </div>

    <div class="harvest-progress hidden" id="harvestProgress">
        <div style="text-align:center;">
            <div class="harvest-bar"><div class="harvest-bar-fill player" id="playerHarvestBar" style="width:0%"></div></div>
            <div class="harvest-count"><span id="playerHarvested">0</span> collected</div>
        </div>
        <div class="harvest-count" id="remainingParticles">100 remaining</div>
        <div style="text-align:center;">
            <div class="harvest-bar"><div class="harvest-bar-fill enemy" id="enemyHarvestBar" style="width:0%"></div></div>
            <div class="harvest-count"><span id="enemyHarvested">0</span> collected</div>
        </div>
    </div>

    <div class="speed-controls" id="speedControls">
        <button class="speed-btn" data-speed="0.5">¬Ωx</button>
        <button class="speed-btn active" data-speed="1">1x</button>
        <button class="speed-btn" data-speed="2">2x</button>
        <button class="speed-btn" data-speed="3">3x</button>
    </div>

    <div class="abilities-bar" id="abilitiesBar">
        <button class="ability-btn" data-ability="boost" title="Speed Boost">
            ‚ö°
            <span class="key-hint">1</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="shield" title="Shield">
            üõ°Ô∏è
            <span class="key-hint">2</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="emp" title="EMP">
            üí•
            <span class="key-hint">3</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="nuke" title="Nuke">
            ‚ò¢Ô∏è
            <span class="key-hint">4</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="stealth" title="Stealth Attack" id="stealthBtn" style="display:none;">
            üëª
            <span class="key-hint">5</span>
            <div class="cooldown-overlay"></div>
        </button>
    </div>

    <div class="send-percent" id="sendPercent">
        <button class="percent-btn" data-pct="25">25%</button>
        <button class="percent-btn" data-pct="50">50%</button>
        <button class="percent-btn active" data-pct="75">75%</button>
        <button class="percent-btn" data-pct="100">ALL</button>
    </div>

    <div class="planet-legend" id="planetLegend">
        <div style="margin-bottom:8px; padding-bottom:5px; border-bottom:1px solid #333;">
            <div class="legend-item"><div class="legend-icon" style="background:#0ff;border-color:#0ff"></div> <span style="color:#0ff">Your planets (cyan ring)</span></div>
            <div class="legend-item"><div class="legend-icon" style="background:#f44;border-color:#f44"></div> <span style="color:#f44">Enemy planets (red ring)</span></div>
            <div class="legend-item"><div class="legend-icon" style="background:#666;border-color:#666"></div> Neutral (gray)</div>
        </div>
        <div class="legend-item"><div class="legend-icon" style="background:#4a4;border-color:#4a4"></div> Factory (2x prod)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#66f;border-color:#66f"></div> Fortress (2x defense)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#a4a;border-color:#a4a"></div> Wormhole (teleport OUT)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#222;border-color:#f44"></div> Black Hole (danger)</div>
        <div style="margin-top:8px; padding-top:5px; border-top:1px solid #333; color:#0ff;">
            <strong>Double-tap</strong> your planet = select ALL
        </div>
    </div>

    <div class="selection-indicator hidden" id="selectionIndicator">0 planets selected</div>

    <div class="menu" id="menu">
        <h1>üåç PARTICLE CONQUEST</h1>
        <p class="subtitle">Capture all planets to win</p>
        
        <div class="menu-section">
            <h3>Game Mode</h3>
            <div class="difficulty-btns">
                <button class="mode-btn active" data-mode="classic">‚öîÔ∏è Classic</button>
                <button class="mode-btn" data-mode="harvest">üåæ Harvest</button>
            </div>
        </div>
        
        <div class="menu-section">
            <h3>Select Difficulty</h3>
            <div class="difficulty-btns">
                <button class="diff-btn easy" data-diff="easy">Easy</button>
                <button class="diff-btn medium" data-diff="medium">Medium</button>
                <button class="diff-btn hard" data-diff="hard">Hard</button>
                <button class="diff-btn insane" data-diff="insane">Insane</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>Special Features</h3>
            <div class="feature-toggles">
                <div class="feature-toggle" data-feature="stealth">
                    <span class="toggle-icon">üëª</span>
                    <span class="toggle-label">Stealth Attack</span>
                    <span class="toggle-check">‚úì</span>
                </div>
                <div class="feature-toggle" data-feature="comets">
                    <span class="toggle-icon">‚òÑÔ∏è</span>
                    <span class="toggle-label">Comet Showers</span>
                    <span class="toggle-check">‚úì</span>
                </div>
                <div class="feature-toggle" data-feature="fog">
                    <span class="toggle-icon">üå´Ô∏è</span>
                    <span class="toggle-label">Fog of War</span>
                    <span class="toggle-check">‚úì</span>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h4>How to Play</h4>
            <div id="classicInstructions">
                <strong>Tap your planet</strong> ‚Üí <strong>Tap target</strong> to attack<br>
                <strong>Double-tap</strong> your planet ‚Üí Select ALL your planets<br>
                <strong>Tap multiple</strong> planets ‚Üí Unified attack<br><br>
            </div>
            <div id="harvestInstructions" style="display:none;">
                <strong>HARVEST PHASE:</strong> Tap particles ‚Üí Tap YOUR planet to collect<br>
                Race the AI to gather particles before battle begins!<br><br>
            </div>
            
            <h4>Special Planets</h4>
            <em>Factory</em> ‚Äî Produces 2x faster<br>
            <em>Fortress</em> ‚Äî Takes 50% less damage<br>
            <em>Wormhole</em> ‚Äî Units sent FROM here appear at partner<br>
            <em>Black Hole</em> ‚Äî Destroys nearby particles<br><br>
            
            <h4>Abilities (1-5 keys)</h4>
            ‚ö° <strong>Boost</strong> ‚Äî 3x particle speed for 5s<br>
            üõ°Ô∏è <strong>Shield</strong> ‚Äî Protect planet for 8s<br>
            üí• <strong>EMP</strong> ‚Äî Freeze enemy production 6s<br>
            ‚ò¢Ô∏è <strong>Nuke</strong> ‚Äî Destroy 50% units on target<br>
            üëª <strong>Stealth</strong> ‚Äî Hide particles for 3s (toggle on)<br><br>

            <h4>Special Features (toggle above)</h4>
            üëª <strong>Stealth Attack</strong> ‚Äî Your particles invisible to AI<br>
            ‚òÑÔ∏è <strong>Comet Showers</strong> ‚Äî Destroys flying particles<br>
            üå´Ô∏è <strong>Fog of War</strong> ‚Äî Limited visibility
        </div>
    </div>

    <div class="result-screen hidden" id="resultScreen">
        <h1 id="resultTitle">VICTORY!</h1>
        <p id="resultText">You conquered the galaxy!</p>
        <button class="play-again-btn" id="playAgainBtn">Play Again</button>
    </div>

    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;

// Game state
const game = {
    state: 'menu', // menu, harvest, playing, ended
    mode: 'classic', // classic, harvest
    difficulty: 'medium',
    level: 1,
    selectedPlanets: [], // Changed to array for multi-select
    sendPercent: 75,
    speed: 1,
    activeAbility: null,
    lastClickTime: 0,
    lastClickedPlanet: null,
    doubleClickThreshold: 300, // ms
    // Feature toggles
    features: {
        stealth: false,
        comets: false,
        fog: false
    }
};

// Comet system
let comets = [];
let lastCometShower = 0;
const COMET_SHOWER_INTERVAL = 15000; // 15 seconds between showers

// Harvest mode particles
let harvestParticles = [];
const HARVEST_PARTICLE_COUNT = 100;

// Abilities
const abilities = {
    boost: { cooldown: 0, maxCooldown: 20, duration: 5, active: false, activeTime: 0 },
    shield: { cooldown: 0, maxCooldown: 25, duration: 8, active: false, targetPlanet: null, activeTime: 0 },
    emp: { cooldown: 0, maxCooldown: 30, duration: 6, active: false, activeTime: 0 },
    nuke: { cooldown: 0, maxCooldown: 35, active: false, activeTime: 0 },
    stealth: { cooldown: 0, maxCooldown: 25, duration: 3, active: false, activeTime: 0 }
};

// Difficulty settings
const DIFFICULTY = {
    easy: { aiSpeed: 0.4, aiAggression: 0.25, planets: 6, startingUnits: 35, specialPlanets: 1 },
    medium: { aiSpeed: 0.7, aiAggression: 0.45, planets: 8, startingUnits: 40, specialPlanets: 2 },
    hard: { aiSpeed: 1.0, aiAggression: 0.65, planets: 10, startingUnits: 50, specialPlanets: 3 },
    insane: { aiSpeed: 1.3, aiAggression: 0.85, planets: 12, startingUnits: 60, specialPlanets: 4 }
};

// Planet types
const PLANET_TYPES = {
    normal: { productionMult: 1, defenseMult: 1, color: null },
    factory: { productionMult: 2, defenseMult: 1, color: '#44aa44', icon: '‚öôÔ∏è' },
    fortress: { productionMult: 0.7, defenseMult: 2, color: '#6666ff', icon: 'üè∞' },
    wormhole: { productionMult: 0.5, defenseMult: 1, color: '#aa44aa', icon: 'üåÄ' },
    blackhole: { productionMult: 0, defenseMult: 0, color: '#111111', icon: '‚ö´' }
};

// Owner constants
const NEUTRAL = 0, PLAYER = 1, ENEMY = 2;

// Helper to convert hex to rgba
function hexToRgba(hex, alpha) {
    hex = hex.replace('#', '');
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// Colors
const COLORS = {
    [NEUTRAL]: { main: '#666666', glow: '#444444', particle: '#888888' },
    [PLAYER]: { main: '#00ffff', glow: '#00aaff', particle: '#00ffff' },
    [ENEMY]: { main: '#ff4444', glow: '#ff2222', particle: '#ff6666' }
};

let planets = [];
let flyingParticles = [];
let bgParticles = [];
let effects = [];
let wormholePairs = [];

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

// Effects system
class Effect {
    constructor(type, x, y, data = {}) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.data = data;
        this.age = 0;
        this.maxAge = data.duration || 1;
    }
    
    update(dt) {
        this.age += dt;
        return this.age < this.maxAge;
    }
    
    draw() {
        const progress = this.age / this.maxAge;
        
        switch(this.type) {
            case 'capture':
                const radius = this.data.radius * (1 + progress * 2);
                const alpha = 1 - progress;
                ctx.strokeStyle = hexToRgba(this.data.color, alpha);
                ctx.lineWidth = 4 * (1 - progress);
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 2;
                    const dist = radius * 0.8;
                    const px = this.x + Math.cos(angle) * dist;
                    const py = this.y + Math.sin(angle) * dist;
                    ctx.fillStyle = hexToRgba(this.data.color, alpha * 0.78);
                    ctx.beginPath();
                    ctx.arc(px, py, 4 * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 'explosion':
                const expRadius = 50 * progress;
                const expAlpha = 1 - progress;
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, expRadius);
                grad.addColorStop(0, `rgba(255, 200, 100, ${expAlpha})`);
                grad.addColorStop(0.5, `rgba(255, 100, 50, ${expAlpha * 0.5})`);
                grad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, expRadius, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'shield':
                if (!this.data.planet) return;
                const shieldAlpha = 0.3 + Math.sin(this.age * 10) * 0.1;
                ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.data.planet.x, this.data.planet.y, this.data.planet.size + 20, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha * 0.5})`;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + this.age;
                    const r = this.data.planet.size + 20;
                    ctx.beginPath();
                    ctx.moveTo(
                        this.data.planet.x + Math.cos(angle) * r,
                        this.data.planet.y + Math.sin(angle) * r
                    );
                    ctx.lineTo(
                        this.data.planet.x + Math.cos(angle + Math.PI/3) * r,
                        this.data.planet.y + Math.sin(angle + Math.PI/3) * r
                    );
                    ctx.stroke();
                }
                break;
                
            case 'wormhole':
                const wAlpha = 0.5 - progress * 0.5;
                ctx.strokeStyle = `rgba(170, 68, 170, ${wAlpha})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 20 + i * 10 + progress * 30, 
                           this.age * 3 + i, this.age * 3 + i + Math.PI);
                    ctx.stroke();
                }
                break;
                
            case 'selectAll':
                // Flash effect when selecting all planets
                const selectAlpha = (1 - progress) * 0.5;
                ctx.strokeStyle = `rgba(0, 255, 255, ${selectAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.data.radius + progress * 50, 0, Math.PI * 2);
                ctx.stroke();
                break;
        }
    }
}

// Planet class
class Planet {
    constructor(x, y, size, owner, units, type = 'normal') {
        this.x = x;
        this.y = y;
        this.size = size;
        this.owner = owner;
        this.units = units;
        this.type = type;
        this.typeData = PLANET_TYPES[type];
        this.maxUnits = Math.floor(size * 3);
        // ENHANCED: Production rate now scales more dramatically with size
        // Larger planets (size ~65) produce ~3x faster than small planets (size ~30)
        this.baseProductionRate = (size * size) / 2000; // Quadratic scaling
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.shielded = false;
        this.shieldTime = 0;
        this.empTime = 0;
        this.wormholePartner = null;
        this.incomingAttacks = [];
        this.orbitParticles = [];
        this.blackHoleAngle = 0;
        this.selected = false; // Track selection state
        
        const numOrbits = Math.floor(size / 15);
        for (let i = 0; i < numOrbits; i++) {
            this.orbitParticles.push({
                angle: Math.random() * Math.PI * 2,
                distance: size + 10 + Math.random() * 20,
                speed: (0.5 + Math.random() * 0.5) * (Math.random() < 0.5 ? 1 : -1)
            });
        }
    }
    
    get productionRate() {
        if (this.empTime > 0 && this.owner === ENEMY) return 0;
        return this.baseProductionRate * this.typeData.productionMult;
    }
    
    get defenseMult() {
        let mult = this.typeData.defenseMult;
        if (mult === 0) mult = 0.01;
        if (this.shielded) mult *= 10;
        return mult;
    }
    
    update(dt) {
        if (this.shieldTime > 0) {
            this.shieldTime -= dt;
            if (this.shieldTime <= 0) this.shielded = false;
        }
        
        if (this.empTime > 0) {
            this.empTime -= dt;
        }
        
        if (this.owner !== NEUTRAL && this.units < this.maxUnits && this.type !== 'blackhole') {
            this.units += this.productionRate * dt;
        }
        
        if (this.type === 'blackhole') {
            this.blackHoleAngle += dt * 2;
        }
        
        this.pulsePhase += dt * 2;
        
        for (const p of this.orbitParticles) {
            p.angle += p.speed * dt;
        }
        
        // Filter out stealthed player particles from incoming attacks (AI can't see them)
        this.incomingAttacks = flyingParticles.filter(p =>
            p.target === this && p.owner !== this.owner &&
            !(p.owner === PLAYER && p.stealthTime > 0)
        );
        
        // Update selection state based on game.selectedPlanets
        this.selected = game.selectedPlanets.includes(this);
    }
    
    draw() {
        const baseColor = this.typeData.color || COLORS[this.owner].main;
        const glowColor = this.typeData.color || COLORS[this.owner].glow;
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.05;
        
        // Black hole special rendering
        if (this.type === 'blackhole') {
            const bhGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
            bhGrad.addColorStop(0, '#000');
            bhGrad.addColorStop(0.5, 'rgba(50, 0, 50, 0.8)');
            bhGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = bhGrad;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 68, 68, 0.53)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size * 1.5, this.size * 0.5, 
                           this.blackHoleAngle + i * 0.5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#f44';
            ctx.lineWidth = 2;
            ctx.stroke();
            return;
        }
        
        // Wormhole special rendering
        if (this.type === 'wormhole') {
            ctx.strokeStyle = 'rgba(170, 68, 170, 0.53)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const spiralAngle = this.pulsePhase + i * Math.PI / 2;
                ctx.beginPath();
                for (let t = 0; t < 1; t += 0.05) {
                    const r = this.size * t;
                    const a = spiralAngle + t * Math.PI * 2;
                    const px = this.x + Math.cos(a) * r;
                    const py = this.y + Math.sin(a) * r;
                    if (t === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
        }
        
        // Glow
        const gradient = ctx.createRadialGradient(
            this.x, this.y, this.size * 0.5,
            this.x, this.y, this.size * 2
        );
        gradient.addColorStop(0, hexToRgba(glowColor, 0.25));
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Planet body
        ctx.fillStyle = hexToRgba(baseColor, 0.19);
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = this.type === 'fortress' ? 4 : 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // OWNERSHIP RING
        if (this.owner !== NEUTRAL) {
            const ownerColor = COLORS[this.owner].main;
            ctx.strokeStyle = ownerColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = hexToRgba(ownerColor, 0.4);
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
        } else {
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Type indicator
        if (this.typeData.icon) {
            ctx.font = `${this.size * 0.4}px system-ui`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.typeData.icon, this.x, this.y - this.size * 0.5);
        }
        
        // SELECTION RING - Enhanced for multi-select
        if (this.selected) {
            const selectionPulse = (Math.sin(Date.now() / 150) + 1) / 2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 + selectionPulse * 0.3})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Selection glow
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + selectionPulse * 0.2})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // Selection number indicator
            const selIndex = game.selectedPlanets.indexOf(this) + 1;
            if (game.selectedPlanets.length > 1) {
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`#${selIndex}`, this.x + this.size + 20, this.y - this.size - 5);
            }
        }
        
        // Incoming attack warning
        if (this.incomingAttacks.length > 0 && this.owner === PLAYER) {
            const warningPulse = (Math.sin(Date.now() / 100) + 1) / 2;
            ctx.strokeStyle = `rgba(255, 100, 100, ${0.3 + warningPulse * 0.5})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 25, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#f44';
            ctx.font = 'bold 12px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`‚ö†Ô∏è ${this.incomingAttacks.length}`, this.x, this.y - this.size - 30);
        }
        
        // Shield effect
        if (this.shielded) {
            const shieldAlpha = 0.3 + Math.sin(this.pulsePhase * 3) * 0.1;
            ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 18, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // EMP effect
        if (this.empTime > 0 && this.owner === ENEMY) {
            ctx.strokeStyle = 'rgba(255, 240, 0, 0.53)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 10, this.pulsePhase, this.pulsePhase + Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Orbiting particles
        const orbitColor = COLORS[this.owner].particle;
        ctx.fillStyle = orbitColor;
        for (const p of this.orbitParticles) {
            const px = this.x + Math.cos(p.angle) * p.distance;
            const py = this.y + Math.sin(p.angle) * p.distance;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Unit count
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.max(14, this.size / 3)}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(Math.floor(this.units), this.x, this.y);
        
        // Production rate indicator (small text showing rate)
        if (this.owner !== NEUTRAL && this.type !== 'blackhole') {
            const rate = this.productionRate.toFixed(1);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '10px system-ui';
            ctx.fillText(`+${rate}/s`, this.x, this.y + this.size * 0.4);
        }
        
        // Ownership label
        if (this.owner === PLAYER) {
            ctx.fillStyle = COLORS[PLAYER].main;
            ctx.font = 'bold 10px system-ui';
            ctx.fillText('YOU', this.x, this.y + this.size + 18);
        } else if (this.owner === ENEMY) {
            ctx.fillStyle = COLORS[ENEMY].main;
            ctx.font = 'bold 10px system-ui';
            ctx.fillText('AI', this.x, this.y + this.size + 18);
        }
    }
    
    containsPoint(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return Math.sqrt(dx * dx + dy * dy) <= this.size + 20;
    }
}

// Flying particle
class FlyingParticle {
    constructor(x, y, targetPlanet, owner) {
        this.x = x;
        this.y = y;
        this.target = targetPlanet;
        this.owner = owner;
        this.baseSpeed = 150;
        this.trail = [];
        this.stealthTime = 0; // Time remaining in stealth
    }
    
    get speed() {
        let spd = this.baseSpeed;
        if (this.owner === PLAYER && abilities.boost.active) spd *= 3;
        return spd;
    }
    
    update(dt) {
        // Update stealth timer
        if (this.stealthTime > 0) {
            this.stealthTime -= dt;
        }

        let targetX = this.target.x;
        let targetY = this.target.y;

        // Check for black hole pull
        for (const planet of planets) {
            if (planet.type === 'blackhole') {
                const dx = planet.x - this.x;
                const dy = planet.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200) {
                    const pullForce = (200 - dist) / 200 * 2;
                    this.x += (dx / dist) * pullForce;
                    this.y += (dy / dist) * pullForce;
                }
                
                if (dist < planet.size) {
                    effects.push(new Effect('explosion', this.x, this.y, { duration: 0.3 }));
                    return false;
                }
            }
        }
        
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < this.target.size) {
            if (this.target.type === 'blackhole') {
                effects.push(new Effect('explosion', this.x, this.y, { duration: 0.3 }));
                return false;
            }
            
            if (this.target.owner === this.owner) {
                this.target.units += 1;
            } else {
                const damage = 1 / this.target.defenseMult;
                this.target.units -= damage;
                
                if (this.target.units <= 0) {
                    const prevOwner = this.target.owner;
                    this.target.owner = this.owner;
                    this.target.units = 1;
                    
                    effects.push(new Effect('capture', this.target.x, this.target.y, {
                        duration: 0.8,
                        radius: this.target.size,
                        color: COLORS[this.owner].main
                    }));
                    
                    showFloatText(this.target.x, this.target.y, 'CAPTURED!', COLORS[this.owner].main);
                }
            }
            return false;
        }
        
        this.trail.push({ x: this.x, y: this.y, age: 0 });
        if (this.trail.length > 10) this.trail.shift();
        for (const t of this.trail) t.age += dt;
        
        this.x += (dx / dist) * this.speed * dt;
        this.y += (dy / dist) * this.speed * dt;
        
        this.x += Math.sin(Date.now() / 100 + this.x) * 0.3;
        this.y += Math.cos(Date.now() / 100 + this.y) * 0.3;
        
        return true;
    }
    
    draw() {
        const color = COLORS[this.owner];
        const isStealthed = this.stealthTime > 0 && this.owner === PLAYER;

        // If stealthed, draw with ghostly effect
        const stealthAlpha = isStealthed ? 0.3 : 1;

        for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            const alpha = (1 - i / this.trail.length) * 0.5 * stealthAlpha;
            ctx.fillStyle = hexToRgba(color.particle, alpha);
            ctx.beginPath();
            ctx.arc(t.x, t.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        if (this.owner === PLAYER && abilities.boost.active) {
            ctx.fillStyle = `rgba(255, 240, 0, ${0.5 * stealthAlpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
            ctx.fill();
        }

        // Stealth glow effect
        if (isStealthed) {
            ctx.fillStyle = 'rgba(100, 50, 150, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = hexToRgba(color.particle, stealthAlpha);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = hexToRgba(color.particle, 0.25 * stealthAlpha);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Background particle
class BgParticle {
    constructor() { this.reset(); }

    reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.vx = (Math.random() - 0.5) * 15;
        this.vy = (Math.random() - 0.5) * 15;
        this.size = Math.random() * 1.5 + 0.5;
        this.alpha = Math.random() * 0.3 + 0.1;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        if (this.x < 0 || this.x > W || this.y < 0 || this.y > H) this.reset();
    }

    draw() {
        ctx.fillStyle = `rgba(100, 150, 200, ${this.alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Comet class for comet showers
class Comet {
    constructor() {
        // Random direction: can come from any edge
        const side = Math.floor(Math.random() * 4);
        const speed = 400 + Math.random() * 300;

        switch(side) {
            case 0: // From top
                this.x = Math.random() * W;
                this.y = -50;
                this.vx = (Math.random() - 0.5) * 200;
                this.vy = speed;
                break;
            case 1: // From bottom
                this.x = Math.random() * W;
                this.y = H + 50;
                this.vx = (Math.random() - 0.5) * 200;
                this.vy = -speed;
                break;
            case 2: // From left
                this.x = -50;
                this.y = Math.random() * H;
                this.vx = speed;
                this.vy = (Math.random() - 0.5) * 200;
                break;
            case 3: // From right
                this.x = W + 50;
                this.y = Math.random() * H;
                this.vx = -speed;
                this.vy = (Math.random() - 0.5) * 200;
                break;
        }

        this.size = 8 + Math.random() * 6;
        this.trail = [];
        this.hitRadius = 30;
    }

    update(dt) {
        // Add trail
        this.trail.push({ x: this.x, y: this.y, age: 0 });
        if (this.trail.length > 20) this.trail.shift();
        for (const t of this.trail) t.age += dt;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Check collision with flying particles (not stealthed ones from player perspective)
        for (let i = flyingParticles.length - 1; i >= 0; i--) {
            const p = flyingParticles[i];
            const dx = p.x - this.x;
            const dy = p.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.hitRadius) {
                // Destroy the particle
                effects.push(new Effect('explosion', p.x, p.y, { duration: 0.3 }));
                flyingParticles.splice(i, 1);
            }
        }

        // Return false when off screen
        return !(this.x < -100 || this.x > W + 100 || this.y < -100 || this.y > H + 100);
    }

    draw() {
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            const alpha = (1 - i / this.trail.length) * 0.6;
            const size = this.size * (1 - i / this.trail.length);

            const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size);
            gradient.addColorStop(0, `rgba(255, 200, 100, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(255, 100, 50, ${alpha * 0.5})`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw comet head
        const headGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
        headGradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
        headGradient.addColorStop(0.3, 'rgba(255, 200, 100, 0.8)');
        headGradient.addColorStop(0.6, 'rgba(255, 100, 50, 0.4)');
        headGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = headGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();

        // Bright core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Spawn comet shower
function spawnCometShower() {
    const numComets = 5 + Math.floor(Math.random() * 8);
    showFloatText(W / 2, 100, '‚òÑÔ∏è COMET SHOWER!', '#ff8844');

    for (let i = 0; i < numComets; i++) {
        setTimeout(() => {
            comets.push(new Comet());
        }, i * 150);
    }
}

// Harvest mode particle
class HarvestParticle {
    constructor() {
        this.x = Math.random() * W;
        this.y = 100 + Math.random() * (H - 200);
        this.vx = (Math.random() - 0.5) * 60;
        this.vy = (Math.random() - 0.5) * 60;
        this.size = 6;
        this.grabbed = false;
        this.grabbedBy = null;
        this.targetPlanet = null;
        this.collected = false;
        this.pulsePhase = Math.random() * Math.PI * 2;
    }
    
    update(dt) {
        this.pulsePhase += dt * 5;
        
        if (this.collected) return false;
        
        if (this.grabbed && this.targetPlanet) {
            const dx = this.targetPlanet.x - this.x;
            const dy = this.targetPlanet.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < this.targetPlanet.size) {
                this.targetPlanet.units += 1;
                this.collected = true;
                effects.push(new Effect('capture', this.x, this.y, {
                    duration: 0.3,
                    radius: 10,
                    color: COLORS[this.grabbedBy].main
                }));
                return false;
            }
            
            const speed = 300;
            this.x += (dx / dist) * speed * dt;
            this.y += (dy / dist) * speed * dt;
        } else {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            
            if (this.x < 50 || this.x > W - 50) this.vx *= -1;
            if (this.y < 100 || this.y > H - 100) this.vy *= -1;
            
            this.x = Math.max(50, Math.min(W - 50, this.x));
            this.y = Math.max(100, Math.min(H - 100, this.y));
            
            this.vx += (Math.random() - 0.5) * 20 * dt;
            this.vy += (Math.random() - 0.5) * 20 * dt;
            
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            if (speed > 80) {
                this.vx = (this.vx / speed) * 80;
                this.vy = (this.vy / speed) * 80;
            }
        }
        
        return true;
    }
    
    draw() {
        if (this.collected) return;
        
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
        
        const glowColor = this.grabbed ? COLORS[this.grabbedBy].main : '#ffffff';
        ctx.fillStyle = hexToRgba(glowColor, 0.3);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2 * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        const coreColor = this.grabbed ? COLORS[this.grabbedBy].main : '#ffffff';
        ctx.fillStyle = coreColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.grabbed && this.targetPlanet) {
            ctx.strokeStyle = hexToRgba(COLORS[this.grabbedBy].main, 0.5);
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.targetPlanet.x, this.targetPlanet.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    containsPoint(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return Math.sqrt(dx * dx + dy * dy) <= this.size * 3;
    }
}

function showFloatText(x, y, text, color) {
    const el = document.createElement('div');
    el.className = 'float-text';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    el.textContent = text;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function updateSelectionIndicator() {
    const indicator = document.getElementById('selectionIndicator');
    if (game.selectedPlanets.length > 0) {
        indicator.classList.remove('hidden');
        const totalUnits = game.selectedPlanets.reduce((sum, p) => sum + Math.floor(p.units), 0);
        indicator.textContent = `${game.selectedPlanets.length} planet${game.selectedPlanets.length > 1 ? 's' : ''} selected (${totalUnits} units)`;
    } else {
        indicator.classList.add('hidden');
    }
}

function selectAllPlayerPlanets() {
    game.selectedPlanets = planets.filter(p => p.owner === PLAYER && p.units >= 1);
    
    // Visual feedback
    for (const planet of game.selectedPlanets) {
        effects.push(new Effect('selectAll', planet.x, planet.y, {
            duration: 0.4,
            radius: planet.size
        }));
    }
    
    showFloatText(W / 2, H / 2, `ALL ${game.selectedPlanets.length} PLANETS SELECTED!`, '#0ff');
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = `${game.selectedPlanets.length} planets selected - tap target`;
}

function togglePlanetSelection(planet) {
    const index = game.selectedPlanets.indexOf(planet);
    if (index >= 0) {
        // Deselect
        game.selectedPlanets.splice(index, 1);
    } else {
        // Select
        game.selectedPlanets.push(planet);
    }
    updateSelectionIndicator();
    
    if (game.selectedPlanets.length > 0) {
        document.getElementById('gameStatus').textContent = `${game.selectedPlanets.length} planet${game.selectedPlanets.length > 1 ? 's' : ''} selected - tap target`;
    } else {
        document.getElementById('gameStatus').textContent = 'Select your planet';
    }
}

function generateLevel() {
    const settings = DIFFICULTY[game.difficulty];
    const numPlanets = settings.planets + Math.floor(game.level / 2);

    planets = [];
    flyingParticles = [];
    harvestParticles = [];
    effects = [];
    wormholePairs = [];
    comets = [];
    lastCometShower = Date.now(); // Reset comet timer
    game.selectedPlanets = [];
    selectedHarvestParticle = null;

    for (const key in abilities) {
        abilities[key].cooldown = 0;
        abilities[key].active = false;
        if (abilities[key].targetPlanet) abilities[key].targetPlanet = null;
    }

    // Show/hide stealth button based on feature toggle
    document.getElementById('stealthBtn').style.display = game.features.stealth ? 'flex' : 'none';
    
    const positions = [];
    const minDist = 130;
    const margin = 80;
    
    for (let i = 0; i < numPlanets; i++) {
        let x, y, valid, attempts = 0;
        
        do {
            x = margin + Math.random() * (W - margin * 2);
            y = margin + 70 + Math.random() * (H - margin * 2 - 160);
            valid = true;
            
            for (const pos of positions) {
                if (Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2) < minDist) {
                    valid = false;
                    break;
                }
            }
            attempts++;
        } while (!valid && attempts < 100);
        
        positions.push({ x, y });
    }
    
    const specialTypes = ['factory', 'fortress', 'wormhole', 'wormhole', 'blackhole'];
    const numSpecials = Math.min(settings.specialPlanets, Math.max(0, positions.length - 2));
    const specialIndices = [];
    
    const availableIndices = positions.length - 2;
    if (availableIndices > 0) {
        while (specialIndices.length < numSpecials) {
            const idx = 1 + Math.floor(Math.random() * availableIndices);
            if (!specialIndices.includes(idx)) specialIndices.push(idx);
        }
    }
    
    let wormholeCount = 0;
    const wormholePlanets = [];
    
    const startUnits = game.mode === 'harvest' ? 5 : settings.startingUnits;
    
    for (let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        const size = 30 + Math.random() * 35;
        let owner = NEUTRAL;
        let units = 10 + Math.random() * 15;
        let type = 'normal';
        
        if (i === 0) {
            owner = PLAYER;
            units = startUnits;
        } else if (i === positions.length - 1) {
            owner = ENEMY;
            units = startUnits;
        } else if (specialIndices.includes(i)) {
            type = specialTypes[specialIndices.indexOf(i) % specialTypes.length];
            if (type === 'blackhole') {
                units = 0;
                owner = NEUTRAL;
            }
        }
        
        const planet = new Planet(pos.x, pos.y, size, owner, units, type);
        planets.push(planet);
        
        if (type === 'wormhole') {
            wormholePlanets.push(planet);
        }
    }
    
    for (let i = 0; i < wormholePlanets.length - 1; i += 2) {
        if (wormholePlanets[i + 1]) {
            wormholePlanets[i].wormholePartner = wormholePlanets[i + 1];
            wormholePlanets[i + 1].wormholePartner = wormholePlanets[i];
        }
    }
    
    if (game.mode === 'harvest') {
        for (let i = 0; i < HARVEST_PARTICLE_COUNT; i++) {
            harvestParticles.push(new HarvestParticle());
        }
        game.state = 'harvest';
        document.getElementById('harvestHud').classList.remove('hidden');
        document.getElementById('harvestProgress').classList.remove('hidden');
        document.getElementById('abilitiesBar').classList.add('hidden');
        document.getElementById('sendPercent').classList.add('hidden');
        updateHarvestUI();
    } else {
        game.state = 'playing';
        document.getElementById('harvestHud').classList.add('hidden');
        document.getElementById('harvestProgress').classList.add('hidden');
        document.getElementById('abilitiesBar').classList.remove('hidden');
        document.getElementById('sendPercent').classList.remove('hidden');
    }
    
    document.getElementById('levelInfo').textContent = `Level ${game.level} ‚Ä¢ ${game.difficulty.toUpperCase()} ‚Ä¢ ${game.mode.toUpperCase()}`;
    updateSelectionIndicator();
}

function initBgParticles() {
    bgParticles = [];
    for (let i = 0; i < 80; i++) {
        bgParticles.push(new BgParticle());
    }
}

let selectedHarvestParticle = null;
let playerHarvested = 0;
let enemyHarvested = 0;
let lastAIHarvest = 0;

function updateHarvestUI() {
    const remaining = harvestParticles.filter(p => !p.grabbed && !p.collected).length;
    const total = HARVEST_PARTICLE_COUNT;
    
    document.getElementById('playerHarvested').textContent = playerHarvested;
    document.getElementById('enemyHarvested').textContent = enemyHarvested;
    document.getElementById('remainingParticles').textContent = remaining + ' remaining';
    document.getElementById('playerHarvestBar').style.width = (playerHarvested / total * 100) + '%';
    document.getElementById('enemyHarvestBar').style.width = (enemyHarvested / total * 100) + '%';
}

function updateHarvestAI(dt) {
    const settings = DIFFICULTY[game.difficulty];
    const now = Date.now();
    
    const grabInterval = 800 / settings.aiSpeed;
    if (now - lastAIHarvest < grabInterval) return;
    lastAIHarvest = now;
    
    const available = harvestParticles.filter(p => !p.grabbed && !p.collected);
    if (available.length === 0) return;
    
    const particle = available[Math.floor(Math.random() * available.length)];
    
    const enemyPlanets = planets.filter(p => p.owner === ENEMY);
    if (enemyPlanets.length === 0) return;
    
    let targetPlanet;
    if (Math.random() < 0.7) {
        targetPlanet = enemyPlanets.reduce((a, b) => a.size > b.size ? a : b);
    } else {
        targetPlanet = enemyPlanets[Math.floor(Math.random() * enemyPlanets.length)];
    }
    
    particle.grabbed = true;
    particle.grabbedBy = ENEMY;
    particle.targetPlanet = targetPlanet;
    enemyHarvested++;
    updateHarvestUI();
}

function checkHarvestComplete() {
    const remaining = harvestParticles.filter(p => !p.collected).length;
    
    if (remaining === 0) {
        game.state = 'playing';
        document.getElementById('harvestHud').classList.add('hidden');
        document.getElementById('harvestProgress').classList.add('hidden');
        document.getElementById('abilitiesBar').classList.remove('hidden');
        document.getElementById('sendPercent').classList.remove('hidden');
        document.getElementById('gameStatus').textContent = 'Battle begins! Select your planet';
        showFloatText(W / 2, H / 2, '‚öîÔ∏è BATTLE BEGINS!', '#fff');
    }
}

function sendUnits(from, to, percent) {
    const numToSend = Math.floor(from.units * (percent / 100));
    if (numToSend < 1) return;
    
    from.units -= numToSend;
    
    let spawnPlanet = from;
    if (from.type === 'wormhole' && from.wormholePartner) {
        spawnPlanet = from.wormholePartner;
        effects.push(new Effect('wormhole', from.x, from.y, { duration: 0.5 }));
        effects.push(new Effect('wormhole', spawnPlanet.x, spawnPlanet.y, { duration: 0.5 }));
    }
    
    for (let i = 0; i < numToSend; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = spawnPlanet.size + Math.random() * 15;
        const x = spawnPlanet.x + Math.cos(angle) * dist;
        const y = spawnPlanet.y + Math.sin(angle) * dist;
        
        setTimeout(() => {
            flyingParticles.push(new FlyingParticle(x, y, to, from.owner));
        }, i * 25);
    }
}

// Unified attack from all selected planets
function sendUnifiedAttack(target, percent) {
    if (game.selectedPlanets.length === 0) return;
    
    for (const planet of game.selectedPlanets) {
        if (planet !== target && planet.units >= 1) {
            sendUnits(planet, target, percent);
        }
    }
    
    // Clear selection after attack
    game.selectedPlanets = [];
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

let lastAIAction = 0;

function updateAI(dt) {
    const settings = DIFFICULTY[game.difficulty];
    const now = Date.now();
    
    if (now - lastAIAction < 800 / settings.aiSpeed) return;
    lastAIAction = now;
    
    const aiPlanets = planets.filter(p => p.owner === ENEMY && p.units > 8);
    if (aiPlanets.length === 0) return;
    
    if (Math.random() > settings.aiAggression) return;
    
    const source = aiPlanets[Math.floor(Math.random() * aiPlanets.length)];
    
    let bestTarget = null;
    let bestScore = -Infinity;
    
    for (const planet of planets) {
        if (planet === source || planet.type === 'blackhole') continue;
        
        const dist = Math.sqrt((planet.x - source.x) ** 2 + (planet.y - source.y) ** 2);
        let score = 0;
        
        if (planet.owner === PLAYER) {
            score = 100 - planet.units * planet.defenseMult - dist / 15;
            if (planet.shielded) score -= 200;
        } else if (planet.owner === NEUTRAL) {
            score = 60 - planet.units - dist / 8;
            if (planet.type === 'factory') score += 30;
            if (planet.type === 'fortress') score += 20;
        } else {
            score = -100;
        }
        
        if (planet.type === 'wormhole' && planet.owner !== ENEMY) score += 25;
        
        if (score > bestScore) {
            bestScore = score;
            bestTarget = planet;
        }
    }
    
    if (bestTarget && bestScore > -30) {
        let percent = 50;
        if (bestTarget.owner === PLAYER && bestTarget.units < source.units * 0.4) percent = 80;
        if (bestTarget.owner === NEUTRAL) percent = Math.min(70, (bestTarget.units + 5) / source.units * 100);
        
        sendUnits(source, bestTarget, percent);
    }
}

function updateAbilities(dt) {
    for (const key in abilities) {
        const ab = abilities[key];
        
        if (ab.cooldown > 0) ab.cooldown -= dt;
        
        if (ab.active && ab.activeTime > 0) {
            ab.activeTime -= dt;
            if (ab.activeTime <= 0) {
                ab.active = false;
            }
        }
        
        const btn = document.querySelector(`[data-ability="${key}"]`);
        if (btn) {
            const overlay = btn.querySelector('.cooldown-overlay');
            if (ab.cooldown > 0) {
                btn.classList.add('cooldown');
                overlay.style.height = (ab.cooldown / ab.maxCooldown * 100) + '%';
            } else {
                btn.classList.remove('cooldown');
                overlay.style.height = '0%';
            }
            
            btn.classList.toggle('active', ab.active || game.activeAbility === key);
        }
    }
    
    if (abilities.shield.targetPlanet) {
        if (abilities.shield.targetPlanet.shieldTime <= 0) {
            abilities.shield.targetPlanet = null;
        }
    }
}

function activateAbility(abilityName) {
    const ab = abilities[abilityName];
    if (ab.cooldown > 0) return;

    // Stealth requires the feature to be enabled
    if (abilityName === 'stealth' && !game.features.stealth) return;

    switch (abilityName) {
        case 'boost':
            ab.active = true;
            ab.activeTime = ab.duration;
            ab.cooldown = ab.maxCooldown;
            showFloatText(W / 2, H / 2, '‚ö° BOOST ACTIVATED!', '#ff0');
            break;

        case 'stealth':
            ab.active = true;
            ab.activeTime = ab.duration;
            ab.cooldown = ab.maxCooldown;
            // Apply stealth to all current player flying particles
            for (const p of flyingParticles) {
                if (p.owner === PLAYER) {
                    p.stealthTime = ab.duration;
                }
            }
            showFloatText(W / 2, H / 2, 'üëª STEALTH ACTIVATED!', '#a0a');
            break;

        case 'shield':
        case 'nuke':
        case 'emp':
            game.activeAbility = abilityName;
            document.getElementById('gameStatus').textContent = `Select target for ${abilityName.toUpperCase()}`;
            break;
    }
}

function useAbilityOnTarget(planet) {
    const abilityName = game.activeAbility;
    const ab = abilities[abilityName];
    
    switch (abilityName) {
        case 'shield':
            if (planet.owner !== PLAYER) {
                showFloatText(planet.x, planet.y, 'Must target your planet!', '#f44');
                return;
            }
            planet.shielded = true;
            planet.shieldTime = ab.duration;
            ab.targetPlanet = planet;
            ab.cooldown = ab.maxCooldown;
            showFloatText(planet.x, planet.y, 'üõ°Ô∏è SHIELDED!', '#4af');
            break;
            
        case 'emp':
            if (planet.owner !== ENEMY) {
                showFloatText(planet.x, planet.y, 'Must target enemy!', '#f44');
                return;
            }
            for (const p of planets) {
                if (p.owner === ENEMY) {
                    p.empTime = ab.duration;
                }
            }
            ab.cooldown = ab.maxCooldown;
            effects.push(new Effect('explosion', planet.x, planet.y, { duration: 0.5 }));
            showFloatText(planet.x, planet.y, 'üí• EMP!', '#ff0');
            break;
            
        case 'nuke':
            if (planet.owner === PLAYER || planet.type === 'blackhole') {
                showFloatText(planet.x, planet.y, "Can't nuke that!", '#f44');
                return;
            }
            const destroyed = Math.floor(planet.units * 0.5);
            planet.units -= destroyed;
            ab.cooldown = ab.maxCooldown;
            effects.push(new Effect('explosion', planet.x, planet.y, { duration: 0.6 }));
            showFloatText(planet.x, planet.y, `‚ò¢Ô∏è -${destroyed}`, '#f84');
            break;
    }
    
    game.activeAbility = null;
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

function checkWinCondition() {
    const playerPlanets = planets.filter(p => p.owner === PLAYER).length;
    const enemyPlanets = planets.filter(p => p.owner === ENEMY).length;
    const playerFlying = flyingParticles.filter(p => p.owner === PLAYER).length;
    const enemyFlying = flyingParticles.filter(p => p.owner === ENEMY).length;
    
    if (enemyPlanets === 0 && enemyFlying === 0) {
        endGame(true);
    } else if (playerPlanets === 0 && playerFlying === 0) {
        endGame(false);
    }
}

function endGame(victory) {
    game.state = 'ended';
    
    const screen = document.getElementById('resultScreen');
    const title = document.getElementById('resultTitle');
    const text = document.getElementById('resultText');
    
    if (victory) {
        screen.className = 'result-screen victory';
        title.textContent = 'VICTORY!';
        text.textContent = `Level ${game.level} conquered!`;
        game.level++;
    } else {
        screen.className = 'result-screen defeat';
        title.textContent = 'DEFEAT';
        text.textContent = 'The enemy has won...';
    }
    
    screen.classList.remove('hidden');
}

function startGame(difficulty) {
    game.difficulty = difficulty;
    game.level = 1;
    game.activeAbility = null;
    game.selectedPlanets = [];
    playerHarvested = 0;
    enemyHarvested = 0;
    
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('resultScreen').classList.add('hidden');
    
    generateLevel();
}

function updateStats() {
    let playerUnits = 0, enemyUnits = 0;
    
    for (const p of planets) {
        if (p.owner === PLAYER) playerUnits += Math.floor(p.units);
        if (p.owner === ENEMY) enemyUnits += Math.floor(p.units);
    }
    
    playerUnits += flyingParticles.filter(p => p.owner === PLAYER).length;
    enemyUnits += flyingParticles.filter(p => p.owner === ENEMY).length;
    
    document.getElementById('playerStats').textContent = playerUnits;
    document.getElementById('enemyStats').textContent = enemyUnits;
}

function drawWormholeConnections() {
    for (const planet of planets) {
        if (planet.type === 'wormhole' && planet.wormholePartner) {
            const partner = planet.wormholePartner;
            
            if (planets.indexOf(planet) > planets.indexOf(partner)) continue;
            
            ctx.strokeStyle = 'rgba(170, 68, 170, 0.27)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 10]);
            ctx.beginPath();
            ctx.moveTo(planet.x, planet.y);
            ctx.lineTo(partner.x, partner.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}

// Draw attack preview lines from all selected planets
function drawAttackPreviewLines(targetX, targetY) {
    for (const planet of game.selectedPlanets) {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(planet.x, planet.y);
        ctx.lineTo(targetX, targetY);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Arrow at target
    if (game.selectedPlanets.length > 0) {
        const centerX = game.selectedPlanets.reduce((s, p) => s + p.x, 0) / game.selectedPlanets.length;
        const centerY = game.selectedPlanets.reduce((s, p) => s + p.y, 0) / game.selectedPlanets.length;
        const angle = Math.atan2(targetY - centerY, targetX - centerX);
        
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.moveTo(targetX, targetY);
        ctx.lineTo(targetX - 15 * Math.cos(angle - 0.4), targetY - 15 * Math.sin(angle - 0.4));
        ctx.lineTo(targetX - 15 * Math.cos(angle + 0.4), targetY - 15 * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
    }
}

// Fog of War drawing
function drawFogOfWar() {
    if (!game.features.fog) return;

    // Create fog canvas overlay
    ctx.save();

    // Draw full fog first
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, W, H);

    // Use destination-out to cut holes for player visibility
    ctx.globalCompositeOperation = 'destination-out';

    // Cut visibility around player planets
    for (const planet of planets) {
        if (planet.owner === PLAYER) {
            const visRadius = planet.size * 5; // Visibility radius based on planet size
            const gradient = ctx.createRadialGradient(
                planet.x, planet.y, planet.size,
                planet.x, planet.y, visRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, visRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Also reveal around player's flying particles
    for (const p of flyingParticles) {
        if (p.owner === PLAYER) {
            const visRadius = 60;
            const gradient = ctx.createRadialGradient(
                p.x, p.y, 5,
                p.x, p.y, visRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(p.x, p.y, visRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    ctx.restore();
}

// Check if a point is visible to the player (for fog of war)
function isVisibleToPlayer(x, y) {
    if (!game.features.fog) return true;

    for (const planet of planets) {
        if (planet.owner === PLAYER) {
            const dx = x - planet.x;
            const dy = y - planet.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < planet.size * 5) return true;
        }
    }

    for (const p of flyingParticles) {
        if (p.owner === PLAYER) {
            const dx = x - p.x;
            const dy = y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 60) return true;
        }
    }

    return false;
}

// Game loop
let lastTime = 0;
let currentTouch = null;

function animate(time) {
    const realDt = Math.min((time - lastTime) / 1000, 0.1);
    const dt = realDt * game.speed;
    lastTime = time;
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    
    for (const p of bgParticles) {
        p.update(realDt);
        p.draw();
    }
    
    if (game.state === 'harvest') {
        harvestParticles = harvestParticles.filter(p => p.update(dt));
        effects = effects.filter(e => e.update(dt));
        
        updateHarvestAI(dt);
        checkHarvestComplete();
        
        for (const planet of planets) planet.draw();
        for (const p of harvestParticles) p.draw();
        for (const e of effects) e.draw();
        
        if (selectedHarvestParticle && !selectedHarvestParticle.grabbed) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(selectedHarvestParticle.x, selectedHarvestParticle.y, 20, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    if (game.state === 'playing') {
        for (const planet of planets) planet.update(dt);
        flyingParticles = flyingParticles.filter(p => p.update(dt));
        effects = effects.filter(e => e.update(dt));

        // Update comets
        if (game.features.comets) {
            comets = comets.filter(c => c.update(dt));

            // Spawn comet showers periodically
            const now = Date.now();
            if (now - lastCometShower > COMET_SHOWER_INTERVAL) {
                lastCometShower = now;
                spawnCometShower();
            }
        }

        updateAI(dt);
        updateAbilities(realDt);
        checkWinCondition();
        updateStats();

        drawWormholeConnections();

        for (const planet of planets) planet.draw();
        for (const e of effects) e.draw();
        for (const p of flyingParticles) p.draw();

        // Draw comets
        for (const c of comets) c.draw();

        // Attack preview lines when planets are selected and mouse is moving
        if (game.selectedPlanets.length > 0 && currentTouch) {
            drawAttackPreviewLines(currentTouch.x, currentTouch.y);
        }

        // Draw fog of war on top
        drawFogOfWar();
    }
    
    if (game.state === 'menu' || game.state === 'ended') {
        drawWormholeConnections();
        for (const planet of planets) planet.draw();
    }
    
    requestAnimationFrame(animate);
}

// Input handling with double-click detection
function handleStart(x, y) {
    const now = Date.now();
    
    // Harvest mode input
    if (game.state === 'harvest') {
        if (selectedHarvestParticle && !selectedHarvestParticle.grabbed) {
            for (const planet of planets) {
                if (planet.containsPoint(x, y) && planet.owner === PLAYER) {
                    selectedHarvestParticle.grabbed = true;
                    selectedHarvestParticle.grabbedBy = PLAYER;
                    selectedHarvestParticle.targetPlanet = planet;
                    playerHarvested++;
                    updateHarvestUI();
                    selectedHarvestParticle = null;
                    document.getElementById('gameStatus').textContent = 'Tap more particles!';
                    return;
                }
            }
        }
        
        for (const particle of harvestParticles) {
            if (!particle.grabbed && !particle.collected && particle.containsPoint(x, y)) {
                selectedHarvestParticle = particle;
                document.getElementById('gameStatus').textContent = 'Now tap YOUR planet to collect!';
                return;
            }
        }
        
        selectedHarvestParticle = null;
        document.getElementById('gameStatus').textContent = 'Tap particles to grab them!';
        return;
    }
    
    if (game.state !== 'playing') return;
    
    // Check if using ability
    if (game.activeAbility) {
        for (const planet of planets) {
            if (planet.containsPoint(x, y)) {
                useAbilityOnTarget(planet);
                return;
            }
        }
        game.activeAbility = null;
        document.getElementById('gameStatus').textContent = 'Select your planet';
        return;
    }
    
    // Check for planet clicks
    for (const planet of planets) {
        if (planet.containsPoint(x, y)) {
            if (planet.owner === PLAYER) {
                // Check for double-click
                const isDoubleClick = (now - game.lastClickTime < game.doubleClickThreshold) && 
                                      game.lastClickedPlanet === planet;
                
                game.lastClickTime = now;
                game.lastClickedPlanet = planet;
                
                if (isDoubleClick) {
                    // Double-click: Select ALL player planets
                    selectAllPlayerPlanets();
                } else {
                    // Single click: Toggle this planet's selection
                    togglePlanetSelection(planet);
                }
            } else {
                // Clicked on non-player planet: This is a target!
                if (game.selectedPlanets.length > 0) {
                    sendUnifiedAttack(planet, game.sendPercent);
                }
            }
            return;
        }
    }
    
    // Clicked on empty space - clear selection
    game.selectedPlanets = [];
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

function handleEnd(x, y) {
    // Not used for drag anymore, but keep for potential future use
}

function handleMove(x, y) {
    currentTouch = { x, y };
}

// Mouse
canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
canvas.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));

// Touch
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); });
canvas.addEventListener('touchend', e => { e.preventDefault(); if (e.changedTouches.length) handleEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); });

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    if (game.state !== 'playing') return;

    if (e.key === '1') activateAbility('boost');
    if (e.key === '2') activateAbility('shield');
    if (e.key === '3') activateAbility('emp');
    if (e.key === '4') activateAbility('nuke');
    if (e.key === '5') activateAbility('stealth');
    if (e.key === 'a' || e.key === 'A') selectAllPlayerPlanets(); // 'A' for select All
    if (e.key === 'Escape') {
        game.activeAbility = null;
        game.selectedPlanets = [];
        updateSelectionIndicator();
        document.getElementById('gameStatus').textContent = 'Select your planet';
    }
});

// UI Events
document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.mode = this.dataset.mode;
        
        document.getElementById('classicInstructions').style.display = game.mode === 'classic' ? 'block' : 'none';
        document.getElementById('harvestInstructions').style.display = game.mode === 'harvest' ? 'block' : 'none';
    });
});

document.querySelectorAll('.diff-btn').forEach(btn => {
    btn.addEventListener('click', () => startGame(btn.dataset.diff));
});

document.getElementById('playAgainBtn').addEventListener('click', () => {
    document.getElementById('resultScreen').classList.add('hidden');
    playerHarvested = 0;
    enemyHarvested = 0;
    generateLevel();
});

document.querySelectorAll('.percent-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.percent-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.sendPercent = parseInt(this.dataset.pct);
    });
});

document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.speed = parseFloat(this.dataset.speed);
    });
});

document.querySelectorAll('.ability-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        activateAbility(this.dataset.ability);
    });
});

// Feature toggles
document.querySelectorAll('.feature-toggle').forEach(toggle => {
    toggle.addEventListener('click', function() {
        const feature = this.dataset.feature;
        game.features[feature] = !game.features[feature];
        this.classList.toggle('active', game.features[feature]);
    });
});

// Init
window.addEventListener('resize', resize);
resize();
initBgParticles();
requestAnimationFrame(animate);
    </script>
</body>
</html>
